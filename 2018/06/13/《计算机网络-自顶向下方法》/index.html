<!DOCTYPE html>
<html style="display: none;" lang="zh">
    <head>
    <meta charset="utf-8">
    <!--
        © Material Theme
        https://github.com/viosey/hexo-theme-material
        Version: 1.5.2 -->
    <script>
        window.materialVersion = "1.5.2"
        // Delete localstorage with these tags
        window.oldVersion = [
            'codestartv1',
            '1.3.4',
            '1.4.0',
            '1.4.0b1',
            '1.5.0'
        ]
    </script>

    <!-- dns prefetch -->
    <meta http-equiv="x-dns-prefetch-control" content="on">














    <!-- Meta & Info -->
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="renderer" content="webkit">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!-- Title -->
    
    <title>
        
            《计算机网络-自顶向下方法》笔记 | 
        
        星辰大海
    </title>

    <!-- Favicons -->
    <link rel="icon shortcut" type="image/ico" href="/img/favicon.png">
    <link rel="icon" href="/img/favicon.png">

    <meta name="format-detection" content="telephone=no"/>
    <meta name="description" itemprop="description" content="">
    <meta name="keywords" content="">
    <meta name="theme-color" content="#330066">

    <!-- Disable Fucking Bloody Baidu Tranformation -->
    <meta http-equiv="Cache-Control" content="no-transform" />
    <meta http-equiv="Cache-Control" content="no-siteapp" />

    <!--[if lte IE 9]>
        <link rel="stylesheet" href="/css/ie-blocker.css">

        
            <script src="/js/ie-blocker.zhCN.js"></script>
        
    <![endif]-->

    <!-- Import lsloader -->
    <script>(function(){window.lsloader={jsRunSequence:[],jsnamemap:{},cssnamemap:{}};lsloader.removeLS=function(a){try{localStorage.removeItem(a)}catch(b){}};lsloader.setLS=function(a,c){try{localStorage.setItem(a,c)}catch(b){}};lsloader.getLS=function(a){var c="";try{c=localStorage.getItem(a)}catch(b){c=""}return c};versionString="/*"+(window.materialVersion||"unknownVersion")+"*/";lsloader.clean=function(){try{var b=[];for(var a=0;a<localStorage.length;a++){b.push(localStorage.key(a))}b.forEach(function(e){var f=lsloader.getLS(e);if(window.oldVersion){var d=window.oldVersion.reduce(function(g,h){return g||f.indexOf("/*"+h+"*/")!==-1},false);if(d){lsloader.removeLS(e)}}})}catch(c){}};lsloader.clean();lsloader.load=function(f,a,b,d){if(typeof b==="boolean"){d=b;b=undefined}d=d||false;b=b||function(){};var e;e=this.getLS(f);if(e&&e.indexOf(versionString)===-1){this.removeLS(f);this.requestResource(f,a,b,d);return}if(e){var c=e.split(versionString)[0];if(c!=a){console.log("reload:"+a);this.removeLS(f);this.requestResource(f,a,b,d);return}e=e.split(versionString)[1];if(d){this.jsRunSequence.push({name:f,code:e});this.runjs(a,f,e)}else{document.getElementById(f).appendChild(document.createTextNode(e));b()}}else{this.requestResource(f,a,b,d)}};lsloader.requestResource=function(b,e,a,c){var d=this;if(c){this.iojs(e,b,function(h,f,g){d.setLS(f,h+versionString+g);d.runjs(h,f,g)})}else{this.iocss(e,b,function(f){document.getElementById(b).appendChild(document.createTextNode(f));d.setLS(b,e+versionString+f)},a)}};lsloader.iojs=function(d,b,g){var a=this;a.jsRunSequence.push({name:b,code:""});try{var f=new XMLHttpRequest();f.open("get",d,true);f.onreadystatechange=function(){if(f.readyState==4){if((f.status>=200&&f.status<300)||f.status==304){if(f.response!=""){g(d,b,f.response);return}}a.jsfallback(d,b)}};f.send(null)}catch(c){a.jsfallback(d,b)}};lsloader.iocss=function(f,c,h,a){var b=this;try{var g=new XMLHttpRequest();g.open("get",f,true);g.onreadystatechange=function(){if(g.readyState==4){if((g.status>=200&&g.status<300)||g.status==304){if(g.response!=""){h(g.response);a();return}}b.cssfallback(f,c,a)}};g.send(null)}catch(d){b.cssfallback(f,c,a)}};lsloader.iofonts=function(f,c,h,a){var b=this;try{var g=new XMLHttpRequest();g.open("get",f,true);g.onreadystatechange=function(){if(g.readyState==4){if((g.status>=200&&g.status<300)||g.status==304){if(g.response!=""){h(g.response);a();return}}b.cssfallback(f,c,a)}};g.send(null)}catch(d){b.cssfallback(f,c,a)}};lsloader.runjs=function(f,c,e){if(!!c&&!!e){for(var b in this.jsRunSequence){if(this.jsRunSequence[b].name==c){this.jsRunSequence[b].code=e}}}if(!!this.jsRunSequence[0]&&!!this.jsRunSequence[0].code&&this.jsRunSequence[0].status!="failed"){var a=document.createElement("script");a.appendChild(document.createTextNode(this.jsRunSequence[0].code));a.type="text/javascript";document.getElementsByTagName("head")[0].appendChild(a);this.jsRunSequence.shift();if(this.jsRunSequence.length>0){this.runjs()}}else{if(!!this.jsRunSequence[0]&&this.jsRunSequence[0].status=="failed"){var d=this;var a=document.createElement("script");a.src=this.jsRunSequence[0].path;a.type="text/javascript";this.jsRunSequence[0].status="loading";a.onload=function(){d.jsRunSequence.shift();if(d.jsRunSequence.length>0){d.runjs()}};document.body.appendChild(a)}}};lsloader.tagLoad=function(b,a){this.jsRunSequence.push({name:a,code:"",path:b,status:"failed"});this.runjs()};lsloader.jsfallback=function(c,b){if(!!this.jsnamemap[b]){return}else{this.jsnamemap[b]=b}for(var a in this.jsRunSequence){if(this.jsRunSequence[a].name==b){this.jsRunSequence[a].code="";this.jsRunSequence[a].status="failed";this.jsRunSequence[a].path=c}}this.runjs()};lsloader.cssfallback=function(e,c,b){if(!!this.cssnamemap[c]){return}else{this.cssnamemap[c]=1}var d=document.createElement("link");d.type="text/css";d.href=e;d.rel="stylesheet";d.onload=d.onerror=b;var a=document.getElementsByTagName("script")[0];a.parentNode.insertBefore(d,a)};lsloader.runInlineScript=function(c,b){var a=document.getElementById(b).innerText;this.jsRunSequence.push({name:c,code:a});this.runjs()}})();</script>

    <!-- Import queue -->
    <script>function Queue(){this.dataStore=[];this.offer=b;this.poll=d;this.execNext=a;this.debug=false;this.startDebug=c;function b(e){if(this.debug){console.log("Offered a Queued Function.")}if(typeof e==="function"){this.dataStore.push(e)}else{console.log("You must offer a function.")}}function d(){if(this.debug){console.log("Polled a Queued Function.")}return this.dataStore.shift()}function a(){var e=this.poll();if(e!==undefined){if(this.debug){console.log("Run a Queued Function.")}e()}}function c(){this.debug=true}}var queue=new Queue();</script>

    <!-- Import CSS -->
    
        <style id="material_css"></style><script>if(typeof window.lsLoadCSSMaxNums === "undefined")window.lsLoadCSSMaxNums = 0;window.lsLoadCSSMaxNums++;lsloader.load("material_css","/css/material.min.css?Z7a72R1E4SxzBKR/WGctOA==",function(){if(typeof window.lsLoadCSSNums === "undefined")window.lsLoadCSSNums = 0;window.lsLoadCSSNums++;if(window.lsLoadCSSNums == window.lsLoadCSSMaxNums)document.documentElement.style.display="";}, false)</script>
        <style id="style_css"></style><script>if(typeof window.lsLoadCSSMaxNums === "undefined")window.lsLoadCSSMaxNums = 0;window.lsLoadCSSMaxNums++;lsloader.load("style_css","/css/style.min.css?MKetZV3cUTfDxvMffaOezg==",function(){if(typeof window.lsLoadCSSNums === "undefined")window.lsLoadCSSNums = 0;window.lsLoadCSSNums++;if(window.lsLoadCSSNums == window.lsLoadCSSMaxNums)document.documentElement.style.display="";}, false)</script>

        

    

    

    <!-- Config CSS -->

<!-- Other Styles -->
<style>
  body, html {
    font-family: Roboto, "Helvetica Neue", Helvetica, "PingFang SC", "Hiragino Sans GB", "Microsoft YaHei", "微软雅黑", Arial, sans-serif;
    overflow-x: hidden !important;
  }
  
  code {
    font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
  }

  a {
    color: #6600cc;
  }

  .mdl-card__media,
  #search-label,
  #search-form-label:after,
  #scheme-Paradox .hot_tags-count,
  #scheme-Paradox .sidebar_archives-count,
  #scheme-Paradox .sidebar-colored .sidebar-header,
  #scheme-Paradox .sidebar-colored .sidebar-badge{
    background-color: #330066 !important;
  }

  /* Sidebar User Drop Down Menu Text Color */
  #scheme-Paradox .sidebar-colored .sidebar-nav>.dropdown>.dropdown-menu>li>a:hover,
  #scheme-Paradox .sidebar-colored .sidebar-nav>.dropdown>.dropdown-menu>li>a:focus {
    color: #330066 !important;
  }

  #post_entry-right-info,
  .sidebar-colored .sidebar-nav li:hover > a,
  .sidebar-colored .sidebar-nav li:hover > a i,
  .sidebar-colored .sidebar-nav li > a:hover,
  .sidebar-colored .sidebar-nav li > a:hover i,
  .sidebar-colored .sidebar-nav li > a:focus i,
  .sidebar-colored .sidebar-nav > .open > a,
  .sidebar-colored .sidebar-nav > .open > a:hover,
  .sidebar-colored .sidebar-nav > .open > a:focus,
  #ds-reset #ds-ctx .ds-ctx-entry .ds-ctx-head a {
    color: #330066 !important;
  }

  .toTop {
    background: #757575 !important;
  }

  .material-layout .material-post>.material-nav,
  .material-layout .material-index>.material-nav,
  .material-nav a {
    color: #757575;
  }

  #scheme-Paradox .MD-burger-layer {
    background-color: #757575;
  }

  #scheme-Paradox #post-toc-trigger-btn {
    color: #757575;
  }

  .post-toc a:hover {
    color: #6600cc;
    text-decoration: underline;
  }

</style>


<!-- Theme Background Related-->

    <style>
      body{
        background-image: url(/img/bg.png);
      }
    </style>




<!-- Fade Effect -->

    <style>
      .fade {
        transition: all 800ms linear;
        -webkit-transform: translate3d(0,0,0);
        -moz-transform: translate3d(0,0,0);
        -ms-transform: translate3d(0,0,0);
        -o-transform: translate3d(0,0,0);
        transform: translate3d(0,0,0);
        opacity: 1;
      }

      .fade.out{
        opacity: 0;
      }
    </style>


<!-- Import Font -->
<!-- Import Roboto -->

    <link href="https://fonts.googleapis.com/css?family=Roboto:300,400,500" rel="stylesheet">


<!-- Import Material Icons -->


    <style id="material_icons"></style><script>if(typeof window.lsLoadCSSMaxNums === "undefined")window.lsLoadCSSMaxNums = 0;window.lsLoadCSSMaxNums++;lsloader.load("material_icons","/css/material-icons.css?pqhB/Rd/ab0H2+kZp0RDmw==",function(){if(typeof window.lsLoadCSSNums === "undefined")window.lsLoadCSSNums = 0;window.lsLoadCSSNums++;if(window.lsLoadCSSNums == window.lsLoadCSSMaxNums)document.documentElement.style.display="";}, false)</script>




    <!-- Import jQuery -->
    
        <script>lsloader.load("jq_js","/js/jquery.min.js?ezyEvm8ST5CGfpA+kFFi1g==", true)</script>
    

    <!-- WebAPP Icons -->
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="application-name" content="星辰大海">
    <meta name="msapplication-starturl" content="http://blog.venus10.com/2018/06/13/《计算机网络-自顶向下方法》/">
    <meta name="msapplication-navbutton-color" content="#330066">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-title" content="星辰大海">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon" href="/img/favicon.png">

    <!-- Site Verification -->
    
    

    <!-- RSS -->
    

    <!-- The Open Graph protocol -->
    <meta property="og:url" content="http://blog.venus10.com/2018/06/13/《计算机网络-自顶向下方法》/">
    <meta property="og:type" content="blog">
    <meta property="og:title" content="《计算机网络-自顶向下方法》笔记 | 星辰大海">
    <meta property="og:image" content="/img/favicon.png">
    <meta property="og:description" content="">
    

    
        <meta property="article:published_time" content="Wed Jun 13 2018 22:22:27 GMT+0800">
        <meta property="article:modified_time" content="Sun Jun 17 2018 14:54:16 GMT+0800">
    

    <!-- The Twitter Card protocol -->
    <meta name="twitter:card" content="summary_large_image">

    <!-- Add canonical link for SEO -->
    
        <link rel="canonical" href="http://blog.venus10.com/2018/06/13/《计算机网络-自顶向下方法》/index.html" />
    

    <!-- Structured-data for SEO -->
    
        


<script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "BlogPosting",
    "mainEntityOfPage": "http://blog.venus10.com/2018/06/13/《计算机网络-自顶向下方法》/index.html",
    "headline": "《计算机网络-自顶向下方法》笔记",
    "datePublished": "Wed Jun 13 2018 22:22:27 GMT+0800",
    "dateModified": "Sun Jun 17 2018 14:54:16 GMT+0800",
    "author": {
        "@type": "Person",
        "name": "Mars687",
        "image": {
            "@type": "ImageObject",
            "url": "/img/avatar.png"
        },
        "description": "Welcome to my world!"
    },
    "publisher": {
        "@type": "Organization",
        "name": "星辰大海",
        "logo": {
            "@type":"ImageObject",
            "url": "/img/favicon.png"
        }
    },
    "keywords": "",
    "description": "",
}
</script>


    

    <!-- Analytics -->
    
    
    

    <!-- Custom Head -->
    

</head>


    
        <body id="scheme-Paradox" class="lazy">
            <div class="material-layout  mdl-js-layout has-drawer is-upgraded">
                

                <!-- Main Container -->
                <main class="material-layout__content" id="main">

                    <!-- Top Anchor -->
                    <div id="top"></div>

                    
                        <!-- Hamburger Button -->
                        <button class="MD-burger-icon sidebar-toggle">
                            <span class="MD-burger-layer"></span>
                        </button>
                    

                    <!-- Post TOC -->

    
    <!-- Back Button -->
    <!--
    <div class="material-back" id="backhome-div" tabindex="0">
        <a class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon"
           href="#" onclick="window.history.back();return false;"
           target="_self"
           role="button"
           data-upgraded=",MaterialButton,MaterialRipple">
            <i class="material-icons" role="presentation">arrow_back</i>
            <span class="mdl-button__ripple-container">
                <span class="mdl-ripple"></span>
            </span>
        </a>
    </div>
    -->


    <!-- Left aligned menu below button -->
    
    
    <button id="post-toc-trigger-btn"
        class="mdl-button mdl-js-button mdl-button--icon">
        <i class="material-icons">format_list_numbered</i>
    </button>

    <ul class="post-toc-wrap mdl-menu mdl-menu--bottom-left mdl-js-menu mdl-js-ripple-effect" for="post-toc-trigger-btn" style="max-height:80vh; overflow-y:scroll;">
        <ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#计算机网络和因特网"><span class="post-toc-number">1.</span> <span class="post-toc-text">计算机网络和因特网</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#什么是因特网"><span class="post-toc-number">1.1.</span> <span class="post-toc-text">什么是因特网</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#具体构成描述"><span class="post-toc-number">1.1.1.</span> <span class="post-toc-text">具体构成描述</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#服务描述"><span class="post-toc-number">1.1.2.</span> <span class="post-toc-text">服务描述</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#名词解释"><span class="post-toc-number">1.1.3.</span> <span class="post-toc-text">名词解释</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#网络边缘"><span class="post-toc-number">1.2.</span> <span class="post-toc-text">网络边缘</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#接入网"><span class="post-toc-number">1.2.1.</span> <span class="post-toc-text">接入网</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#物理媒介"><span class="post-toc-number">1.2.2.</span> <span class="post-toc-text">物理媒介</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#网络核心"><span class="post-toc-number">1.3.</span> <span class="post-toc-text">网络核心</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#电路交换"><span class="post-toc-number">1.3.1.</span> <span class="post-toc-text">电路交换</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#分布式散列表"><span class="post-toc-number">1.3.2.</span> <span class="post-toc-text">分布式散列表</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#运输层"><span class="post-toc-number">2.</span> <span class="post-toc-text">运输层</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#概述和运输层服务"><span class="post-toc-number">2.1.</span> <span class="post-toc-text">概述和运输层服务</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#运输层和网络层的关系"><span class="post-toc-number">2.1.1.</span> <span class="post-toc-text">运输层和网络层的关系</span></a></li></ol></li></ol></li></ol>
    </ul>
    




<!-- Layouts -->

    <!-- Post Module -->
    <div class="material-post_container">

        <div class="material-post mdl-grid">
            <div class="mdl-card mdl-shadow--4dp mdl-cell mdl-cell--12-col">

                <!-- Post Header(Thumbnail & Title) -->
                
    <!-- Paradox Post Header -->
    
        
            <!-- Random Thumbnail -->
            <div class="post_thumbnail-random mdl-card__media mdl-color-text--grey-50">
            <script type="text/ls-javascript" id="post-thumbnail-script">
    var randomNum = Math.floor(Math.random() * 36 + 1);

    $('.post_thumbnail-random').attr('data-original', '/' + randomNum + '.png');
    $('.post_thumbnail-random').addClass('lazy');
</script>

        
    
            <p class="article-headline-p">
                《计算机网络-自顶向下方法》笔记
            </p>
        </div>





                
                    <!-- Paradox Post Info -->
                    <div class="mdl-color-text--grey-700 mdl-card__supporting-text meta">

    <!-- Author Avatar -->
    <div id="author-avatar">
        <img src="/img/avatar.png" width="44px" height="44px" alt="Author Avatar"/>
    </div>
    <!-- Author Name & Date -->
    <div>
        <strong>Mars687</strong>
        <span>6月 13, 2018</span>
    </div>

    <div class="section-spacer"></div>

    <!-- Favorite -->
    <!--
        <button id="article-functions-like-button" class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon btn-like">
            <i class="material-icons" role="presentation">favorite</i>
            <span class="visuallyhidden">favorites</span>
        </button>
    -->

    <!-- Qrcode -->
    

    <!-- Tags (bookmark) -->
    

    <!-- Share -->
    
        <button id="article-fuctions-share-button" class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon">
    <i class="material-icons" role="presentation">share</i>
    <span class="visuallyhidden">share</span>
</button>
<ul class="mdl-menu mdl-menu--bottom-right mdl-js-menu mdl-js-ripple-effect" for="article-fuctions-share-button">
    

    

    <!-- Share Weibo -->
    
        <a class="post_share-link" href="http://service.weibo.com/share/share.php?appkey=&title=《计算机网络-自顶向下方法》笔记&url=http://blog.venus10.com/2018/06/13/《计算机网络-自顶向下方法》/index.html&pic=http://blog.venus10.com/img/favicon.png&searchPic=false&style=simple" target="_blank">
            <li class="mdl-menu__item">
                分享到微博
            </li>
        </a>
    

    <!-- Share Twitter -->
    
        <a class="post_share-link" href="https://twitter.com/intent/tweet?text=《计算机网络-自顶向下方法》笔记&url=http://blog.venus10.com/2018/06/13/《计算机网络-自顶向下方法》/index.html&via=Mars687" target="_blank">
            <li class="mdl-menu__item">
                分享到 Twitter
            </li>
        </a>
    

    <!-- Share Facebook -->
    
        <a class="post_share-link" href="https://www.facebook.com/sharer/sharer.php?u=http://blog.venus10.com/2018/06/13/《计算机网络-自顶向下方法》/index.html" target="_blank">
            <li class="mdl-menu__item">
                分享到 Facebook
            </li>
        </a>
    

    <!-- Share Google+ -->
    
        <a class="post_share-link" href="https://plus.google.com/share?url=http://blog.venus10.com/2018/06/13/《计算机网络-自顶向下方法》/index.html" target="_blank">
            <li class="mdl-menu__item">
                分享到 Google+
            </li>
        </a>
    

    <!-- Share LinkedIn -->
    

    <!-- Share QQ -->
    

    <!-- Share Telegram -->
    
</ul>

    
</div>

                

                <!-- Post Content -->
                <div id="post-content" class="mdl-color-text--grey-700 mdl-card__supporting-text fade out">
    
        <h2 id="计算机网络和因特网"><a href="#计算机网络和因特网" class="headerlink" title="计算机网络和因特网"></a>计算机网络和因特网</h2><p>计算机网络的定义：将分布在不同地理位置上的具有独立工作能力的计算机、终端及其附属设备用通信设备和通信线路连接起来，并配置网络软件，以实现计算机资源共享的系统。</p>
<h3 id="什么是因特网"><a href="#什么是因特网" class="headerlink" title="什么是因特网"></a>什么是因特网</h3><h4 id="具体构成描述"><a href="#具体构成描述" class="headerlink" title="具体构成描述"></a>具体构成描述</h4><p>基本硬件和软件组成角度：Internet 互联了众多称作主机或者终端系统的设备，他们被认为位于网络边缘，主机又可分为客户机（client）和服务器（server）。这些设备通过通信链路（也就是物理线缆）连接，链路中间还有分组交换机。主机之间交换数据时将数据分组发送，并通过分组交换机分配包数据。常见的分组交换机有路由器和链路层交换机。主机通过ISP（Internet 服务提供商）接入Internet 。所有Internet 通讯必须遵循一定的协议。其规范称作互联网标准。</p>
<h4 id="服务描述"><a href="#服务描述" class="headerlink" title="服务描述"></a>服务描述</h4><p>Internet 是提供如下服务的计算机网络：允许离散的应用在终端上交换数据，比如下载软件和浏览器浏览网页等。它还为这些应用提供两种服务：面向连接的服务（TCP）以及无连接的无依赖性服务（UDP）。简单地说，面向连接的服务有握手程序，还必须确认包是否正确发送和接受，但是无连接服务不需要担心另一方的问题，只要发或者接就行了。</p>
<h4 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h4><ul>
<li>端系统/主机：和因特网相连的计算机等设备（如TV，Web服务器，手提电脑）。 </li>
<li>通信链路：同轴电缆，铜线，光纤，无线电频谱 。</li>
<li>分组：当一台端系统有数据要向另一台端系统发送时，端系统将数据分段并在每段加上首部字节，由此形成的信息包称为分组。一个分组所经历的一系列通信链路和分组交换机称为通过该网络的路径。 </li>
<li>协议：定义了在两个或多个通信实体之间交换的报文格式和次序，以及在报文传输和接收或其它事件方面所采取的动作。</li>
</ul>
<h3 id="网络边缘"><a href="#网络边缘" class="headerlink" title="网络边缘"></a>网络边缘</h3><ul>
<li>接入网：将端系统连接到边缘路由器（edge router）的物理链路。 </li>
<li>边缘路由器：端系统到任何其他远程端系统的路径上的第一台路由器。</li>
</ul>
<h4 id="接入网"><a href="#接入网" class="headerlink" title="接入网"></a>接入网</h4><ul>
<li>家庭接入</li>
</ul>
<p>数字用户线DSL(digital subscriber line)、电缆、光纤到户FTTH(fiber to the home)、拨号（网络发展早期应用较多）</p>
<ul>
<li>企业（和家庭）接入</li>
</ul>
<p>以太网和WiFi</p>
<h4 id="物理媒介"><a href="#物理媒介" class="headerlink" title="物理媒介"></a>物理媒介</h4><ul>
<li>导引型媒介(guided media)</li>
</ul>
<p>电磁波沿着固体媒介传播，如光纤、双绞铜线或同轴电缆。</p>
<ul>
<li>非导引型媒介(unguided media)</li>
</ul>
<p>电磁波在空气或外层空间传播，如无线局域网或数字卫星频道。</p>
<h3 id="网络核心"><a href="#网络核心" class="headerlink" title="网络核心"></a>网络核心</h3><p>网络核心，即互联了因特网端系统的分组交换机和链路的网状网络。</p>
<h4 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a>电路交换</h4><ul>
<li>定义</li>
</ul>
<p>电路交换（circuit switching）：每个主机都直接与一个交换机直接相连，各个交换机之间有物理线缆，如果两台主机要传送信息，其对应的交换机之间必须有一条预留电路。假定每个交换机都有n条电路，那么连接期间该连接获得链路带宽的1/n。</p>
<p>电路交换网络中的多路复用<br>1、频分多路复用（Frequency-Division Multiplexing，FDM）<br>2、时分多路复用（Time-Division Multiplexing，TDM）</p>
<div align="center"><br><img src="http://i64.tinypic.com/51zsw6.jpg" alt="FDM-TDM"><br></div><br><p align="center"><font size="2">对于FDM，每条电路连续地得到部分带宽。对于TDM，每条电路在短时间间隔(即时隙)周期性地得到所有带宽</font></p><br><br>#### 分组交换<br><br>分组交换（packet swiitching）：各种应用在完成任务时要交换报文，报文包含协议要求的内容。主机会把较大的报文分组并发送到分组交换机。交换机使用存储转发传输机制，简单地说就是接受一个报文的全部分组后才输出，这样就会产生存储转发时延。同时，对于每个输出链路，分组交换机还为之生成一个输出缓存或输出队列，因为同一时刻只能向一条链路输出一组信息，其他信息只能在队列中等待，这样会产生排队时延。如果队列已满，新到达的报文分组无法入队，就会产生丢包。<br><br>优劣对比：<br><br><em> 分组交换的反对者：<br><br>分组交换因其端到端时延是变动的和不可预测的（主要是因为排队时延的变动和不可预测所致），故不适合实时服务（例如，电话和视频会议）。

</em> 分组交换的支持者：<br><br>1、它提供了比电路交换更好的带宽共享。<br>2、它比电路交换更简单、 更有效，实现成本更低。<br><br>### 分组交换网中的时延，丢包和吞吐量<br><br>#### 时延概述<br><br>时延分为节点处理时延（nodal processing delay），排队时延（queuing delay），传输时延（transmission delay）和传播时延（propagation delay），这些加起来就是节点总时延（total nodal delay），即<br><br>&gt;节点总时延 = 节点处理时延 + 排队时延 + 传输时延 + 传播时延<br><br><div><br><img src="http://i68.tinypic.com/2zyzo6p.jpg" alt="chapter1-nodalDelay"><br></div><br><p align="center"><font size="2">路由器A的结点时延</font></p><br><br><em> 处理时延（通常几毫秒）<br>1. 检查分组首部和决定将分组导向哪一个队列；<br>2. 其他：检查比特级差错所需要的时间。

</em> 排队时延（取决于拥塞等级）<br><br>在队列中，当分组在链路上等待传输时所需的时间，取决于先期到达的，正在排队等待想链路传输分组的数量。<br><br><em> 传输时延（L/R，对低速链路很大，毫秒到微秒级）<br><br>1. 将所有分组的比特推向链路所需要的时间。<br>2. 用L比特表示分组的长度，用R bps（即b/s）表示从路由器A到路由器B的链路传输速率。（对于一条10Mbps的以太网链路，速率R = 10Mbps）,传输时延（又称为存储转发时延）是L/R。

</em> 传播时延（几微秒到几百毫秒）<br><br>1. 从该链路的起点到路由器B传播所需要的时间是传播时延。该比特以该链路的传播速率传播。<br>2. 传播时延 = 两台路由器的距离d / 传播速率s。<br>3. 传播速率取决于该链路的物理媒体（即光纤，双绞铜线等），速率范围是2×10<sup>8</sup> ~ 3×10<sup>8</sup> m/s<br><br>&gt;偶然想到了《技术之瞳》中提到的一个知识点：光纤数据传输速率为 2×100000 km/s。之所以不是3×10<sup>8</sup> m/s，是因为真空中的光速是3×10<sup>8</sup> m/s，而为使光信号在传播介质中形成全反射现象，能量无衰减，采用了折射率较大的光纤。光纤折射率约为1.5，由介质中的光速v = c/n(折射率)，可得光纤中的光速约为2×10<sup>8</sup>m/s。<br><br>#### 端到端时延<br><br>假定在源主机和目的主机之间有N-1台路由器（那么实际有N条小路径），并且该网络是无拥塞的（因此排队时延是微不足道的），处理时延为d<sub>proc</sub>，每台路由器和源主机的输出速率是 R bps，每条链路的传播时延是d<sub>prop</sub>，节点时延累加起来得到端到端时延：<br><br>&gt;d<sub>end-end</sub> = N(d<sub>proc</sub> + d<sub>trans</sub> + d<sub>prop</sub>)<br><br>传输时延d<sub>trans</sub> = 分组长度L / R<br><br>#### 计算机网络中的吞吐量<br><br>吞吐量：单位时间内通过某个网络（或信道、接口）的数据量，是瓶颈链路（bottleneck link，即找速度最短的那一条链路）的传输速率。<br>吞吐量分为瞬时吞吐量（instancous throughput）和平均吞吐量（average throughput），我们可以把他们类比为以前物理学过的瞬时速度和平均速度。<br><br><div align="center"><br><img src="http://i64.tinypic.com/2n9fgww.jpg" alt="chapter1-throughput"><br></div><br><p align="center"><font size="2">图a.中吞吐量为min{Rc，Rs}。 图b.中吞吐量为min{R1,R2,R3,…,RN}。</font></p><br><br>在确定了吞吐量之后，我们现在近似地（因为没有考虑分组层次和协议）得到从服务器到客户机传输一个F比特的大文件所需要的时间是F/min{R1,R2,R3,…,RN}。<br><br>### 协议层次<br>网络中引入协议栈（protocol stack）概念，自顶向下分别是：<br><br><em> 应用层<br>应用层是网络应用程序及它们的应用层协议存留的地方。包含大量应用普遍需要的协议，支持网络应用。<br>协议为FTP, SMTP, HTTP<br><br>应用层协议分布在多个端系统上，一个端系统中的应用程序使用协议与另一个端系统中的应用程序交换信息的分组。我们把这种位于应用层的信息分组称为报文(message)。

</em> 传输层<br>因特网的传输层在应用程序端点之间传送应用层报文。主机到主机数据传输，负责从应用层接收消息，并传输应用层的message，到达目的后将其上交应用。<br>协议为TCP, UDP<br><br>我们把传输层分组称为报文段(segment) 。<br><br><em> 网络层<br>因特网的网络层负责将称为数据报( datagram) 的网络层分组从一台主机移动到另一台主机。在一台源主机中的因特网运输层协议(TCP 或UDP) 向网络层递交运输层报文段和目的地址，就像你通过邮政服务寄信件时提供一个目的地址一样。网络层通过源和目的地之间的一系列路由器路由数据报。<br>协议为IP, 选路协议

</em> 链路层<br>链路层的任务是将整个帧从一个网络元素移动到邻近的网络元素。在邻近网络元素之间传输数据。<br>协议为PPP(Point-to-Point Protocal——PPP点到点), 以太网(Ethernet)<br><br><em> 物理层<br>物理层负责将链路层帧中每一位(bit)从链路的一端传输到另一端。<br><br>因特网协议栈自顶向下传输时，各层会将上层信息包装，上层信息包装为有效载荷字段，本层信息包装为首部字段。<br>下图中从上往下为封装，下往上为解封装。本书是以因特网协议栈的层次来组织的，采用自顶向下方法，先处理应用层，然后继续向下处理。<br><br><div align="center"><br><img src="http://i63.tinypic.com/16lbq4o.jpg" alt="chapter1-protocalLayer"><br></div><br><p align="center"><font size="2">因特网协议栈分层模型</font></p><br><br>## 应用层<br>### 应用层协议原理<br>应用层协议只能运行在端系统，这种限制促进了应用程序的开发，即开发不用考虑底层网络核心的实现。<br><br>#### 网络应用程序体系结构
</em> 客户机-服务器体系结构（clienl-server archilecture）<br><br>最常见的体系结构，特点是“一对多，一台服务器对应多个客户主机”，服务器主机总是打开着的，接受请求，提供响应给其他客户机主机。服务器是处理所有逻辑的中心，具有固定的 IP 地址。客户机之间不直接通信，要通信必须经过服务器。<br>基础设施密集。虽然客户机/服务器体系结构的特征是“一对多”，但是服务器却并不总是一台，因为有的时候要处理海量的客户机的请求， 一台服务器很快就会不堪重负，所以这个时候常用服务器集群技术（server clustering）创建强大的虚拟服务器。<br><br>应用程序：WEB，FTP，电子邮件，Telnet<br><br><em> P2P体系结构（P2 P architecture）<br>应用程序在间断的主机对之间进行直接通信，这些主机对被称为对等方。<br><br>特点：客户机间的直接通信使得P2P有了强大的自扩展性（self-calability），比如下载文件时接收到文件的主机又可以直接把文件上载给其他的主机，因此对基础设施服务器依赖较小，并且可上载该文件的主机的数量是指数递增的，系统的服务能力只会越来越强。<br><br>应用程序：文件共享(例如BitTorrenl) 、对等方协助下载加速器(例如迅雷)、因特网电话(例如Skype) 和IPTV (例如”迅雷看看”和PPstream) 。<br><br>#### 进程通信
</em> 客户和服务器进程<br><br>网络应用程序由成对的进程组成，在两个不同端系统上的进程，通过跨越计算机网络交换报文（message）。通常将两个进程之一标识为客户，另一个标识为服务器。在给定的一对进程之间的通信会话场景中，发起通信的进程被标识为客户，在会话开始时等待联系的进程是服务器。<br><br><em> 进程与计算机网络之间的接口<br><br>进程通过一个称为套接字(socket)的软件接口向网络发送报文和从网络接收报文。套接字类似每个人房间门前的信箱，发送端应用程序将报文放进套接字这一端，在套接字另一端，运输层协议（TCP/UDP）负责使该报文进入接收进程的套接字（将报文放到另一个人房间门前的信箱）。套接字也被称为应用程序和网络之间的应用程序编程接口（API）。程序开发者可以控制套接字在应用层端的一切，但是对该套接字的运输层端几乎没有控制权，应用程序开发者对于运输层的控制仅限于:<br>①选择运输层协议;<br>②也许能设定几个运输层参数，如最大缓存和最大报文段长度等(将在第3 章中涉及) 。<br><br>一旦应用程序开发者选择了一个运输层协议(如果可供选择的话) ，则应用程序就建立在由该协议提供的运输层服务之上。

</em> 进程寻址<br><br>一台主机的进程向另一台主机的进程发送分组，接收进程需要一个地址。为了标识该进程，需要定义两种信息：<br><br>①主机的地址：用IP地址标识；<br>②定义在目标主机中的接收进程的标识符：用目的地端口号标识。<br><br>#### 可供应用程序使用的运输服务<br>根据运输层协议为应用层程序提供的服务，按下列要求进行分类：<br><br><em> 可靠数据传输( reliable data transfer)：是否容忍数据丢失。
</em> 吞吐量 ：应用程序是否对吞吐量有特定的要求，若是，则称为带宽敏感的应用，否则称为弹性应用。<br><em> 定时：对时延的要求。
</em> 安全性<br><br>#### 因特网提供的运输服务<br><br><em> TCP 服务<br><br>1. 面向连接的服务：在应用层数据报文开始流动之前，TCP让客户和服务器互相交换运输层控制信息，即握手阶段。之后，一条全双工的TCP连接就在两个进程的套接字之间建立了。应用程序结束发送报文时，则拆除该连接。<br><br>2. 可靠的数据传送服务：通信进程能够依靠TCP，无差错、按适当顺序交付所有发送的数据。<br><br>TCP 协议还具有拥塞控制机制：<br>当发送方和接收方之间的网络出现拥塞时，TCP 的拥塞控制机制会抑制发送进程。<br><br>TCP 拥塞控制机制也试图限制每个 TCP 连接，使他们达到公平共享网络带宽的目的。这种服务不一定为通信进程带来直接好处，但是能为因特网带来整体好处。

</em> UDP 服务<br><br>1. UDP 是一种不提供不必要服务的轻量级运输协议，它仅提供最小服务。<br><br>2. UDP 是无连接的，因此在两个进程通信之前无握手。<br><br>3. UDP 协议提供一种不可靠数据传送服务，也就是说，当进程将一个报文发送进 UDP 套接字时，UDP并不保证该报文到达接收进程。不仅如此，到达接收进程的报文也可能是乱序到达的。<br><br>UDP 没有包括拥塞控制机制，所以 UDP 的发送端可以用它选定的任何速率向其下层（网络层）注入数据。<br><br><em> 因特网运输协议所不提供的服务<br>TCP 能提供可靠的数据传输服务，也能通过 SSL 来加强以提供安全服务。<br>今天的因特网通常能够为时间敏感应用提供满意的服务，但不能提供任何定时或带宽保证。<br><br>####  应用层协议<br>应用层协议定义了运行在不同端系统上的进程如何相互传递报文。特别是应用层协议定义了:

</em> 交换报文的类型，例如请求报文和响应报文。<br><em> 各种报文类型的语法，如报文中各个字段及这些字段是如何描述的。
</em> 字段的语义，即这些字段中包含的信息的含义。<br><em> 一个进程何时以及如何发送报文，对报文进行响应的规划。<br><br><div align="center"><br><img src="http://i64.tinypic.com/ru8b5i.jpg" alt="chapter2-applicationLayerProtocals"><br></div><br><p align="center"><font size="2">互联网应用，应用层协议和下层传输协议</font></p><br><br>### Web 和 HTTP<br>#### HTTP 概况
</em> Web 的应用层协议是 超文本传输协议（HTTP） ，它是 Web 的核心。<br><br><em> HTTP 由两个程序实现：一个客户程序和一个服务器程序。客户程序和服务器程序运行在不同的端系统中，通过交换 HTTP 报文进行会话。

</em> HTTP 使用 TCP 作为它的支撑运输协议。客户首先发起一个与服务器的 TCP 连接。一旦该连接建立，该浏览器和服务器进程就可以通过套接字接口访问 TCP。<br><br><em> HTTP 是一个 无状态协议 。服务器向客户发送被请求的文件，而 不存储 任何该客户的状态信息。<br>Web 使用了 客户-服务器 应用程序体系结构。<br><br>#### 非持续连接和持续连接
</em> 非持续连接(non-persistent connection)<br><br>应用程序在采用非持续连接的情况下，客户的每个请求都要建立一个单独的 TCP 连接。<br>简单估算一下从客户请求 HTML 文件到客户收到文件为止所花费的时间。<br><br>往返时间(Round-Trip Time , RTT)：一个短分组从客户到服务器然后再返回客户所花费的时间。<br><br><div align="center"><br><img src="http://i68.tinypic.com/4l0pvl.jpg" alt="chapter2-RTT"><br></div><br><p align="center"><font size="2">请求并接收一个HTML 文件所需的时间估算</font></p><br><br>因此，粗略的讲，总的响应时间就是两个 RTT 加上服务器传输 HTML 文件的时间。<br><br><em> 持续连接(persistent connection)<br><br>在采用持续连接的情况下，服务器再发送响应后保持该 TCP 连接打开。在相同的客户与服务器之间的后续请求和响应报文能够通过相同的连接进行传送。<br><br>一般来说，如果一条连接经过一定的时间间隔（一个可配置的时间间隔）仍未被使用，HTTP 服务器就关闭该连接。HTTP 的默认模式是使用带流水线的持续连接。<br><br>#### HTTP 报文格式

</em> HTTP 请求报文<br><br><code>html
GET /somedir/page.html HTTP/1.1
Host: www.someschool.edu
Connection: close
User-agent: Mozilla/5.0
Accept-language: fr</code><br><br>第一行叫做 请求行(request line) ，其后继的行叫做 首部行(header line)。<br><br>请求行有三个字段：<br>1.方法字段：包括 GET、POST、HEAD、PUT 和 DELETE。绝大部分报文使用 GET 方法。<br>2.URL 字段<br>3.HTTP 版本字段<br><br><div align="center"><br><img src="http://i65.tinypic.com/2gsfotc.jpg" alt="chapter2-requestMessage"><br></div><br><p align="center"><font size="2">请求报文的通用格式</font></p><br><br><em> HTTP 响应报文<br><br>对刚才的请求报文的响应报文：<br><br><code>html
HTTP/1.1 200 OK
Connection: close
Date: Tue, 09 Aug 2011 15:44:04 GMT
Server: Apache/2.2.3 (CentOS)
Last-Modified: Tue, 09 Aug 2011 15:11:03 GMT
Content-Length: 6821
Content-Type: text/html

(data data data data data ......)</code><br><br>响应报文分为三个部分：<br>1.初始状态行(status line)<br>状态行有三个字段：版本协议字段、状态码和相应状态信息。<br>2.6个首部行<br>3.实体主体<br>实体体部分是报文的主要部分，即它包含了所请求的对象本身(表示为dala dala data data . . . ) 。<br><br>下表包括了一些常用的状态码和相关短语


</em> 200 OK 请求成功，信息在返回的响应报文中。<br><em> 301 Moved Permanetly 请求的对象已经被永久转移了，新的 URL 定义在相应报文的 Location：首部行中。客户软件将自动获取新的 URL。
</em> 400 Bad Request 一个通用差错代码，指示该请求不能被服务器理解。<br><em> 404 Not Found 请求的文档不在服务器上。
</em> 505 HTTP Version Not Supported 服务器不支持请求报文使用的 HTTP 协议版本。<br><br><div align="center"><br><img src="http://i64.tinypic.com/erlvz4.jpg" alt="chapter2-responseMessage"><br></div><br><p align="center"><font size="2">响应报文的通用格式</font></p><br><br>#### 用户与服务器的交互：cookie<br><br>HTTP 是无状态的，但是 Web 站点通常希望能够识别用户，为此，HTTP 使用了 cookie ，它允许站点对用户进行跟踪。<br><br>cookie 有 4 个技术组件：<br>1.在 HTTP 响应报文中的一个 cookie 首部行；<br>2.在 HTTP 请求报文中的一个 cookie 首部行；<br>3.在用户端系统中保留有一个 cookie 文件，并由用户的浏览器进行管理；<br>4.位于 Web 站点的一个后端数据库。<br><br><div align="center"><br><img src="http://i63.tinypic.com/ao50ma.jpg" alt="chapter2-cookie"><br></div><br><p align="center"><font size="2">cookie 跟踪用户状态</font></p><br><br>在web站点后台有数据库。其工作原理是，用户第一次访问某服务器时，其响应报文中包含一个Set-cookie字段，该字段的值往往是服务器设定的唯一标识码，浏览器将该字段和服务器主机名等信息保存在本地，以后用户每次访问时，浏览器都会从cookies中找到该站点的标识码放在请求报文中发送，这样服务器就能通过这个唯一标识辨认这个用户，通过用户在网站上的浏览记录采取行为。<br><br>#### Web 缓存<br><br>Web 缓存器(Web cache)也叫代理服务器(proxy server)，是能够代表 Web 服务器来满足 HTTP 请求的网络实体。Web 服务器有自己的磁盘存储空间，并在存储空间中保存着最近存储过的对象的副本。可以配置用户的浏览器，使得用户所有的 HTTP 请求首先指向 Web 缓存器。客户与 Web 缓存器之间的速度通常比较快，所以可以提高访问的速度，降低时延。<br><br>当浏览器申请一个文件时，先建立一个到web缓存的TCP连接，如果缓存服务器上有这个文件就返回，否则，他就建立一个到原始服务器的TCP获得该文件并存储，之后将该文件发回客户端。web缓存可以大幅减少对客户端的响应时间，减少机构内部网络和internet之间的链路通信量并节约带宽。这样会带来的新的问题是，web缓存上的文件可能是陈旧的。为此HTTP引入了条件get，即web缓存在保存一个文件时会记录其最后修改时间，客户端每次请求文件时，web缓存会向原始服务器发送一个带有if-modified-since的报文，如果该文件没有改动就直接把缓存中的文件返回给用户，否则重新下载该文件。<br><br>通过使用内容分发网络(Content Distribution Network, CDN) , Web 缓存器正在因特网中发挥着越来越重要的作用。CDN 公司在因特网上安装了许多地理上分散的缓存器，因而使大量流量实现了本地化。有多个共享的CDN (例如Akamai 和Limelight)和专用的CDN (例如谷歌和微软)。<br><br>#### 条件 GET 方法(conditional GET)<br><br>用来解决 Web 缓存器中的对象拷贝可能是陈旧的的问题。<br><br>若同时满足以下两点的则称为 条件 GET 方法：<br><br><em> 请求报文使用 GET 方法。

</em> 请求报文中包含一个 If-Modified-Since: 首部行。<br><br>### 文件传输协议：FTP<br><br>用两个并行TCP连接，一个控制连接，一个是数据连接。<br><br>如图，用户通过一个FTP用户代理与FTP交互。该用户首先提供远程主机的主机名，使本地主机的FTP客户进程建立一个到远程主机FTP服务器进程的TCP 连接。该用户接着提供用户标识和口令，作为FTP 命令的一部分在该TCP连接上传送。一旦该服务器向该用户授权，用户可以将存放在本地文件系统中的一个或者多个文件复制到远程文件系统(反之亦然)。<br><br><div align="center"><br><img src="http://i67.tinypic.com/14v7fbb.jpg" alt="chapter2-FTP"><br></div><br><p align="center"><font size="2">使用FTP 协议在本地和远程文件系统之间移动文件</font></p><br><br>HTTP 和FTP 都是文件传输协议，并且有很多共同的特点，例如，它们都运行在TCP上 。然而，这两个应用层协议也有一些重要的区别。其中最显著的就是ITP 使用了两个并行的TCP 连接来传输文件， 一个是控制连接(control connection) ，一个是数据连接(data connection) 。控制连接用于在两主机之间传输控制信息，如用户标识、口令、改变远程目录的命令以及”存放(put)”和”获取(get)”文件的命令。数据连接用于实际发送一个文件。因为 FTP 协议使用一个独立的控制连接，所以我们也称FTP的控制信息是带外(out-of-band) 传送的。如你所知， HTTP 协议是在传输文件的同一个TCP 连接中发送请求和响应首部行的。因此， HTTP 也可以说是带内(in-band) 发送控制信息的。FTP协议的控制连接和数据连接如下图所示。<br><br><div align="center"><br><img src="http://i66.tinypic.com/sdmusy.jpg" alt="chapter2-FTP-connection"><br></div><br><p align="center"><font size="2">FTP 协议控制连接和数据连接</font></p><br><br>当用户主机与远程主机开始一个FTP会话时，FTP的客户(用户)端首先在服务器21 号端口与服务器(远程主机)端发起一个用于控制的TCP 连接。FTP的客户端也通过该控制连接发送用户的标识和口令，发送改变远程目录的命令。当FTP 的服务器端从该连接上收到一个文件传输的命令后(无论是向还是来自远程主机) ，就发起一个到客户端的TCP 数据连接。FTP 在该数据连接上准确地传送一个文件，然后关闭该连接。在同一个会话期间，如果用户还需要传输另一个文件，FTP 则打开另一个数据连接。因而对FTP传输而言，控制连接贯穿了整个用户会话期间，但是对会话中的每一次文件传输都需要建立一个新的数据连接(即数据连接是非持续的)。<br><br>FTP 服务器必须在整个会话期间保留用户的状态(state) 。特别是，服务器必须把特定的用户账户与控制连接联系起来，随着用户在远程目录树上徘徊，服务器必须追踪用户在远程目录树上的当前位置。对每个进行中的用户会话的状态信息进行追踪，大大限制了FTP同时维持的会话总数。而另一方面，前面讲过HTTP 是无状态的，即它不必对任何用户状态进行追踪。<br><br>### 因特网中的电子邮件<br><br>电子邮件系统有3个主要组成部分：<br>1.用户代理<br>2.邮件服务器<br>3.简单邮件传输协议（SMTP）<br><br><div align="center"><br><img src="http://i63.tinypic.com/k2q9e.jpg" alt="chapter2-SMTP-connection"><br></div><br><p align="center"><font size="2">因特网电子邮件系统的总体描述</font></p><br><br>#### SMTP<br><br>SMTP 是因特网中电子邮件中主要的应用层协议。它使用 TCP 可靠数据传输。SMTP 限制所有的邮件报文只能采用简单的 7 比特 ASCII 表示。<br>一个简单的邮件发送过程是：从发送方的用户代理开始，传输到发送方的邮件服务器，再传输到接收方的邮件服务器，然后在这里被分发到接收方的邮箱上。<br><br>为了描述SMTP的基本操作.我们观察一种常见的情景。假设Alice 想给Bob 发送一封简单的ASCII报文。<br><br><em> Alice 调用她的邮件代理程序并提供Bob的邮件地址(例如<a href="mailto:bob@someschool.edu" target="_blank" rel="noopener">bob@someschool.edu</a>),撰写报文，然后指示用户代理发送该报文。

</em> Alice 的用户代理把报文发给她的邮件服务器，在那里该报文被放在报文队列中。<br><br><em> 运行在Alice 的邮件服务器上的SMTP 客户端发现了报文队列中的这个报文，它就创建一个到运行在Bob 的邮件服务器上的SMTP 服务器的TCP 连接。

</em> 在经过一些初始SMTP 握手后， SMTP 客户通过该TCP 连接发送Alice 的报文。<br><br><em> 在Bob 的邮件服务器上， SMTP 的服务器端接收该报文。Bob 的邮件服务器然后将该报文放人Bob 的邮箱中。

</em> 在Bob 方便的时候，他调用用户代理阅读该报文。如下图。<br><br><div align="center"><br><img src="http://i68.tinypic.com/w1tik5.jpg" alt="chapter2-SMTP-sendingMessage"><br></div><br><p align="center"><font size="2">Alice 向Bob 发送一条报文</font></p><br><br>如果 Bob 的邮件服务器没有开机，该报文会保留在 Alice 的邮件服务器上并尝试进行新的尝试。这意味着邮件并不会在中间的某个邮件服务器存留。<br><br>&gt;注意：SMTP 一般不使用中间服务器发送邮件，即使这两个邮件服务器位于地球的两端也一样。<br><br>SMTP 用的是持续链接：如果发送邮件服务器有几个报文发往同一个接收邮件服务器，它可以通过同一个 TCP 连接发送所有的的报文。<br><br>#### 与 HTTP 的对比<br><br><em> 相同点：<br><br>都用于从一台主机向另一台主机传送文件。HTTP 从Web 服务器向Web 客户(通常是一个浏览器)传送文件(也称为对<br>象); SMTP 从一个邮件服务器向另一个邮件服务器传送文件(即电子邮件报文) 。当进行文件传送时，持续的HTTP 和SMTP 都使用持续连接。

</em> 不同点：<br><br>1. HTTP 是一个 拉协议(pull protocol)，TCP 连接是由想要接收文件的机器发起的。SMTP 是一个 推协议(push protocol)，TCP连接是由想要发送文件的机器发起的。<br><br>2. SMTP 要求报文必须按照 7 比特 ASCII 码进行编码。HTTP 则没有这种限制。<br><br>3. 在处理包含多种不同类型的文档时。HTTP 把每个对象封装到它自己的 HTTP 响应报文中，SMTP 则把所有报文对象放在一个报文中。<br><br>因为SMTP要求所有对象用ASCII编码，对于图片、视频或者非ASCII字符，就要使用多用途Internet 邮件扩展（MIME）对其添加支持。需要在报文的首部中添加Content-Type和Content-Transfer-Encoding。SMTP的接收方在受到报文后，会在该报文中添加一个Received行表示接受信息。<br><br>#### 邮件访问协议<br><br><em> 第三版的邮局协议(POSl Office Protocol-Version 3 ,POP3)

</em> 因特网邮件访问协议(Intemet Mail Access Protocol , IMAP)<br><br><em> 基于 Web 的电子邮件(HTTP)<br><br>下面考虑邮件如何从接收方的服务器到达接收方主机上的用户代理，也就是邮件访问协议。当用户代理打开一个到邮件服务器的110端口的TCP后，POP3就开始工作了。<br>第一阶段：特许阶段，，用户代理发送(以明文形式)用户名和口令以鉴别用户。<br>第二阶段：事务处理阶段，用户代理取回报文;同时在这个阶段用户代理还能进行如下操作，对报文做删除标记，取消报文删除标记，以及获取邮件的统计信息。<br>第三阶段：更新阶段，它出现在客户发出了quÏl命令之后，目的是结束该POP3会话;这时，该邮件服务器<br>删除那些被标记为删除的报文。<br><br>### DNS：因特网的目录服务<br><br>因特网上的主机的标识有2种方式：

</em> 主机名，如<a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a><br><em> IP地址，如xxx.xxx.xxx.xxx<br><br>#### DNS 提供的服务<br><br>主机可以使用 主机名 和 IP 地址 进行标识。为进行主机名到IP地址转换的目录服务，引入了域名系统<br>(Domain Name System , DNS)。<br><br>DNS 即 域名系统 是：

</em> 一个由分层的 DNS 服务器 实现的分布式数据库。<br><em> 一个使得主机能够查询分布式数据库的应用层协议。<br><br>DNS也是应用层协议，它通常会被其他应用层协议所使用，包括HTTP、SMTP和FTP，将用户的主机名解析为 IP 地址。<br>DNS 还提供了一些重要的服务：

</em> 识别主机别名(host aliasing),用于HTTP、FTP。<br><em> 识别邮件服务器别名(mai] server aliasing)用于SMTP。
</em> 负载分配(load distribution)<br><br>#### DNS 工作机理概述<br><br>假设运行在用户主机上的某些应用程序(如Web 浏览器或邮件阅读器)需要将主机名转换为IP 地址。这些应用程序将调用DNS 的客户端，并指明需要被转换的主机名(在很多基于UNIX 的机器上，应用程序为了执行这种转换需要调用函数gethoslbyname())。用户主机上的DNS 接收到后，向网络中发送一个DNS 查询报文。所有的DNS 请求和回答报文使用UDP 数据报经端口53 发送。经过若干毫秒到若干秒的时延后，用户主机上的DNS 接收到一个提供所希望映射的DNS 回答报文。这个映射结果则被传递到调用DNS 的应用程序。因此，从用户主机上调用应用程序的角度看， DNS 是一个提供简单、直接的转换服务的黑盒子。但事实上，实现这个服务的黑盒子非常复杂，它由分布于全球的大量DNS 服务器以及定义了DNS 服务器与查询主机通信方式的应用层协议组成。<br><br><strong>集中式DNS设计方案</strong><br><br>DNS 的一种简单设计是在因特网上只使用一个DNS 服务器，该服务器包含所有的映射。在这种集中式设计中，客户直接将所有查询直接发往单一的DNS 服务器，同时该DNS 服务器直接对所有的查询客户做出响应。尽管这种设计的简单性非常具有吸引力，但它不适用于当今的因特网，因为因特网有着数量巨大(并持续增长)的主机。这种集中式设计的问题包括:<br><br><em> 单点故障(a single point of failure) 。如果该DNS 服务器崩溃，整个因特网随之瘫痪!
</em> 通信容量(traffic volume)。单个DNS 服务器不得不处理所有的DNS 查询(用于为上亿台主机产生的所有HTTP 请求报文和电子邮件报文服务)。<br><em> 远距离的集中式数据库(distant centralized database) 。单个DNS 服务器不可能”邻近”所有查询客户。如果我们将单台DNS 服务器放在纽约市，那么所有来自澳大利亚的查询必须传播到地球的另一边，中间也许还要经过低速和拥塞的链路。这将导致严重的时延。
</em> 维护(maintenance)。单个DNS 服务器将不得不为所有的因特网主机保留记录。这不仅将使这个中央数据库非常庞大，而且它还不得不为解决每个新添加的主机而频繁更新。<br><br>总的来说，在单一DNS 服务器上运行集中式数据库完全没有可扩展能力。因此， DNS采用了分布式的设计方案。事实上， DNS 是一个在因特网上实现分布式数据库的精彩范例。<br><br><strong>分布式DNS设计方案</strong><br>为了处理扩展性问题， DNS 使用了大量的DNS 服务器，它们以层次方式组织，并且分布在全世界范围内。没有一台DNS 服务器拥有因特网上所有主机的映射。相反，该映射分布在所有的DNS 服务器上。大致说来，有3 种类型的DNS 服务器:根DNS 服务器、顶级域(Top-Level Domain, TLD) DNS 服务器和权威DNS 服务器。这些服务器以下图中所示的层次结构组织起来。<br><br><div align="center"><br><img src="http://i67.tinypic.com/i3w5qd.jpg" alt="chapter2-DNS"><br></div><br><p align="center"><font size="2">DNS 服务器的部分层次结构</font></p><br><br>为了理解这3种类型的DNS 服务器交互的方式，假定一个DNS 客户要决定主机名附 <a href="http://www.amazon.com" target="_blank" rel="noopener">www.amazon.com</a> 的IP地址。粗略说来，将发生下列事件。客户首先与根服务器之一联系，它将返回顶级域名com 的TLD 服务器的IP地址。该客户则与这些TLD服务器之一联系，它将为 amazoo.com 返回权威服务器的IP 地址。最后，该客户与 amazon.com 权威服务器之一联系，它为主机名为 <a href="http://www.amazon.com" target="_blank" rel="noopener">www.amazon.com</a> 返回其IP地址。我们将很快更为详细地考察DNS 查找过程。不过我们先仔细看一下这3种类型的 DNS 服务器。<br><br><em> 根 DNS 服务器<br><br>在因特网上有13个根DNS 服务器(标号为A到M) ，它们中的大部分位于北美洲。

</em> 顶级域（DNS）服务器<br><br>这些服务器负责顶级域名如com 、org 、net 、edu 和gov, 以及所有国家的顶级域名如此、fr ， ca 和jp o Verisign Global Regislry Services 公司维护com 顶级域的TLD 服务器; Educause 公司维护edu 顶级域的TLD 服务器。<br><br><em> 权威DNS服务器<br><br>在因特网上具有公共可访问主机(如Web 服务器和邮件服务器)的每个组织机构必须提供公共可访问的DNS 记录，这些记录将这些主机的名字映射为IP 地址。一个组织机构的权威DNS 服务器收藏了这些DNS 记录。一个组织机构能够选择实现它自己的权威DNS 服务器以保存这些记录;另一种方法是，该组织能够支付费用，让这些记录存储在某个服务提供商的一个权威DNS 服务器中。<br><br><strong>DNS缓存</strong><br><br>与Web缓存器一样，DNS服务器同样有缓存器。为了改善时延性能并减少在因特网上到处传输的DNS 报文数量，DNS 广泛使用了缓存技术。DNS 缓存的原理非常简单。在一个请求链中，当某DNS服务器接收一个DNS 回答(例如，包含主机名到IP 地址的映射)时，它能将该回答中的信息缓存在本地存储器中。<br><br>### P2P应用<br><br>#### P2P文件分发<br><br>1. P2P 体系结构的扩展性<br><br>为了将客户-服务器体系结构与 P2P 体系结构进行比较，阐述 P2P 的内在自扩展性，我们现在考虑一个用于两种体系结构类型的简单定量模型，将一个文件分发给一个固定集合。如图所示，服务器和对等方使用接入链路与因特网相连。其中u<sub>s</sub> 表示服务器接人链路的上载速率， u<sub>i</sub> 表示第i对等方接入链路的上载速率，d<sub>i</sub> 表示了第i对等方接入链路的下载速率。还用 F 表示被分发的文件长度(以比特计)， N 表示要获得的该文件副本的对等方的数量。分发时间(dislribution time) 是所有N 个对等方得到该文件的副本所需要的时间。<br><br><br>我们首先来确定对于客户一服务器体系结构的分发时间，我们将其表示为D<sub>cs</sub>。在客户-服务器体系结构中，没有对等方参与来帮助分发文件。我们做下列观察:

</em> 服务器必须向 N 个对等方的每个传输该文件的一个副本。因此该服务器必须传输 NF 比特。因为该服务器的上载速率是u<sub>s</sub> ， 分发该文件的时间必定是至少为 NF/u<sub>s</sub>。<br><br>* 令d<sub>min</sub>表示具有最小下载速率的对等方的下载速率，即d<sub>min</sub>= min {d<sub>1</sub>，d<sub>2</sub>, …, d<sub>N</sub>} 。具有最小下载速率的对等方不可能在少于F/d<sub>min</sub> 秒时间内获得该文件的所有 F 比特。因此最小分发时间至少为F/d<sub>min</sub>。<br><br>将这两个观察放在一起，我们得到：<br><br><div align="center"><br><img src="http://i67.tinypic.com/2iblrlu.jpg" alt="chapter2-DNS-formu1"><br></div>

<p>我们现在来对P2P 体系结构进行简单的分析，其中每个对等方能够帮助服务器分发该文件。特别是，当一个对等方接收到某些文件数据，它能够使用自己的上载能力重新将数据分发给其他对等方。计算P2P 体系结构的分发时间在某种程度上比计算客户-服务器体系结构的更为复杂，因为分发时间取决于每个对等方如何向其他对等方分发该文件的各个部分。我们做下列观察：</p>
<ul>
<li>在分发的开始，只有服务器具有文件。为了使社区的这些对等方得到该文件，该服务器必须经其接入链路至少发送该文件的每个比特一次。因此，最小分发时间至少是F/u<sub>s</sub>。(与客户-服务器方案不同，由服务器发送过一次的比特可能不必由该服务器再次发送，因为对等方在它们之间可以重新分发这些比特。)</li>
<li>与客户-服务器体系结构相同，具有最低下载速率的对等方不能够以小于F/d<sub>min</sub>秒的分发时间获得所有F 比特。因此最小分发时间至少为F/d<sub>min</sub>。</li>
<li>最后，观察到系统整体的总上载能力等于服务器的上载速率加上每个单独的对等方的上载速率， 即u<sub>total</sub> = u<sub>1</sub>，u<sub>2</sub>, …, u<sub>N</sub>。系统必须向这N个对等方的每一个上载 F 比特，因此总共上载 NF 比特。这不能以快于u<sub>total</sub>的速率完成。因此，最小的分发时间也至少是NF/u<sub>1</sub>，u<sub>2</sub>, …, u<sub>N</sub>。</li>
</ul>
<p>将这三个观察放在一起，我们获得了对自P 的最小分发时间，表示为D<sub>P2P</sub>:</p>
<div align="center"><br><img src="http://i66.tinypic.com/nmdg94.jpg" alt="chapter2-DNS-formu2"><br></div>

<p>我们从下图中看到，对于客户-服务器体系结构，随着对等方数量的增加，分发时间呈线性增长并且没有界。然而，对于P2P 体系结构，最小分发时间不仅总是小于客户-服务器体系结构的分发时间，而且对于任意的对等方数量N， 总是小于1小时。因此，具有P2P 体系结构的应用程序能够是自扩展的。这种扩展性的直接成因是:对等方除了是比特的消费者外,还是它们的重新分发者。</p>
<div align="center"><br><img src="http://i64.tinypic.com/dc518w.jpg" alt="chapter2-"><br></div>

<ol start="2">
<li>BitTorrent</li>
</ol>
<p>BitTorrent 是一种用于文件分发的流行P2P 协议。用BitTorrent 的术语来讲，参与一个特定文件分发的所有对等方的集合被称为一个洪流(torrent) 。在一个洪流中的对等方彼此下载等长度的文件块(chunk) ，典型的块长度为256KB。当一个对等方首次加入一个洪流时，它没有块。随着时间的流逝，它累积了越来越多的块。当它下载块时，也为其他对等方上载了多个块。一且某对等方获得了整个文件，它也许(自私地)离开洪流，或(大公无私地)留在该洪流中并继续向其他对等方上载块。同时，任何对等方可能在任何时候仅具有块的子集就离开该洪流，并在以后重新加人该洪流中。</p>
<h4 id="分布式散列表"><a href="#分布式散列表" class="headerlink" title="分布式散列表"></a>分布式散列表</h4><p>分布式散列表（Distributed Hash Table，DHT）是分布式计算系统中的一类，用来将一个关键值（key）的集合分散到所有在分布式系统中的节点，并且可以有效地将消息转送到唯一一个拥有查询者提供的关键值的节点（Peers）。这里的节点类似散列表中的存储位置。分布式散列表通常是为了拥有极大节点数量的系统，而且在系统的节点常常会加入或离开（例如网络断线）而设计的。在一个结构性的延展网络（overlay network）中，参加的节点需要与系统中一小部份的节点沟通，这也需要使用分布式散列表。分布式散列表可以用以创建更复杂的服务，例如分布式文件系统、点对点技术文件分享系统、合作的网页高速缓存、多播、任播、域名系统以及实时通信等。</p>
<ul>
<li>考虑用网覆盖拓扑DHT（即每个节点跟踪系统中的所有节点）。这种设计的优点和缺点是什么？一个环形的DHT（没有捷径）的优点和缺点是什么？</li>
</ul>
<p>Mesh DHT: 优势在于为了路由一条信息到接近关键值（key）的对等方，只需要跳跃(hop)一次。缺点是每个对等方都必须朱总所有其他在DHT中的对等方。</p>
<p>Circular DHT：优势在于每个对等方只需追踪几个其他对等方，而缺点是为了路由一条信息到接近关键值（key）的对等方需要O(N)次跳跃。</p>
<h2 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h2><h3 id="概述和运输层服务"><a href="#概述和运输层服务" class="headerlink" title="概述和运输层服务"></a>概述和运输层服务</h3><h4 id="运输层和网络层的关系"><a href="#运输层和网络层的关系" class="headerlink" title="运输层和网络层的关系"></a>运输层和网络层的关系</h4><p>网络层提供了主机之间的逻辑通信。而运输层为运行在 不同主机上的进程 提供逻辑通信。<br>运输层协议只工作在端系统上。<br>运输协议能提供的服务受制于底层网络协议的服务模型。<br>网络层协议，即 IP 协议，其服务模型是 尽力而为交付服务 ，但不做任何的保证。是 不可靠服务 。<br>参照书上以东西海岸两个家庭互相写信的经典例子<br>进程 = 堂兄弟姐妹<br>主机 = 家庭<br>运输层协议 = Ann 和 Bill（孩子里收信发信的大哥大姐），分发到兄弟姐妹中，将信从一个人（进程）送到另一个人<br>网络层协议 = 邮政服务，将信从一个家庭（主机）传给另一个家庭<br>运输层协议只工作在主机（端系统）中 = Ann 和 Bill 只在家工作，将信拿到门口的邮箱<br>多种运输层协议，多种服务模型 = Ann 和 Bill 外出，Susan 和 Harvey来收信发信，结果年龄太小，收发邮件次数少，也老丢信<br>运输层服务受制于网络层服务 = 邮政大哥若三天来一次，Ann和Bill就不可能两天收发一次信<br>运输层协议能为应用程序提供可靠数据传输服务 = 若邮政大哥把信弄脏弄丢弄混，Ann 和 Bill 可以清理整理信件，或者让对方下次重新发一次<br>运输层协议能确保应用程序报文不受入侵读取 = 尽管邮政大哥可能被别人骗或者强行看了信件，Ann 和 Bill 也能规定加密方式对信的内容进行加解密，弟弟妹妹们只需要看信的内容<br>多路分解 = Bill 和 Ann从邮递大哥拿到信件，看收信人名字（端口号），然后分别交到他们手上<br>多路复用 = Bill 和 Ann从弟弟妹妹手里拿到信件，帮他们装填信封写上信息<br>3.1.2 因特网运输层概述<br>UDP 提供了一种不可靠、无连接的服务。<br>TCP 提供了一种可靠的、面向连接的服务。<br>进程到进程的数据交付和差错检测是两种最低限度的运输层服务，也是 UDP 能提供的仅有的两种服务。<br>3.2 多路复用与多路分解<br>多路分解： 将运输层报文段中的数据交付到正确的套接字。<br>多路复用： 在源主机从不同的套接字中收集数据块，并为每个数据块封装上首部信息从而生成报文段，然后将报文传递到网络层。<br>运输层多路复用要求：<br>套接字有唯一标识符。<br>每个报文段有特殊字符（端口号）来指示该报文段所要交付到的套接字。<br>端口号：一个 16 比特的数，在 0 ~ 65535 之间。其中 0 ~ 1023 是周知端口号，是受限制的。<br>3.2.1 无连接的多路复用与多路分解<br>一个 UDP 套接字由（目的IP地址，目的端口号）标识。注意是用来标识，不是只有这两个相关字段，还有源端口号、源IP地址字段。源端口号和目的端口号按传递方向反转<br>通常，应用程序的客户端让运输层自动地分配端口号，而服务器则分配一个特定的端口号。<br>3.2.2 面向连接的多路复用与多路分解<br>TCP 套接字是由一个四元组（源 IP 地址，源端口号，目的 IP 地址，目的端口号）来标识的。</p>
<p>3.3 无连接运输：UDP<br>选择 UDP 的原因：<br>关于何时、发送什么数据的应用层控制更为精细。<br>无需连接建立。<br>无连接状态。<br>分组首部开销小。<br>用 UDP 建立可靠数据传输机制可以在应用层中实现。<br>3.3.1 UDP 报文结构<br>这里写图片描述<br>首部只有 4 个字段，每个字段 2 字节 16 位。其中，长度指示了 UDP 报文段中的首部加数据的字节数。</p>
<p>3.3.2 UDP 检验和<br>检验和 是 UDP 的差错检测机制。其实现方法是： </p>
<ol>
<li>将 UDP 报文按 16 比特进行分组。 </li>
<li>先取前面两个16比特数字进行加运算，有溢出记得回卷，即溢出位加到最低位再进行加运算 </li>
<li>2中得到的数再跟下一个16比特数字进行加运算，直到报文末端 </li>
<li>将最终得到的 16 比特的数按位取反即为检验和。</li>
</ol>
<p>注：计算之前的检验和为 0<br>如果传输没有出错，则在接收方处计算的的检验和将是 11111111111111。若不是，则数据有错。<br>3.4 可靠数据传输原理<br>3.4.1 构造可靠数据传输协议<br>经完全可靠信道的可靠数据传输 rdt1.0<br>有限状态机<br>有完全可靠的信道，接收方就不需要提供任何反馈信息给发送方<br>经具有比特差错信道的可靠数据传输 rdt2.0<br>自动重传请求协议（ARQ，又叫停等协议）<br>处理比特差错还需三种协议功能：<br>差错检测。需要利用额外的比特（组原中海明码、奇偶校验码之类）<br>接收方反馈。肯定确认ACK（收到了），否定确认NAK（请再传一遍），接收方没收到确认就不能发送（停等协议）<br>考虑ACK、NAK分组受损的可能性，在数据分组中添加新字段，分组序号0和1（向前取模）<br>重传。接收方收到有差错分组时，发送方重传该分组。<br>经具有比特差错的丢包信道的可靠数据传输 rdt3.0（ 比特交替协议）<br>发送方负责检测和回复丢包工作，对每一个分组维护一个定时器。如果在一个时间段内没收到ACK，则判定为丢包，重传分组，这也引入了冗余数据分组的可能性（时延很大的情况）<br>这里写图片描述<br>3.4.2 流水线可靠数据传输<br>rdt 3.0 是一个功能正确的协议，但是由于它是一个停等协议，大部分的时间都浪费在等待确认上面，所以性能不好。<br>解决这种特殊性能问题的一个简单的方法是：不使用停等方式运行，允许发送方发送多个分组而无需等待确认。这种技术被称为 流水线。<br>要使用流水线技术，则须：<br>增加序号范围。因为要传送多个分组，而每个传输中的分组必须有一个单独的序号。<br>协议的发送方和接收方两端必须能缓存多个分组。发送方至少得能缓存那些已发送但未确认的分组，而接收方或许也需要缓存那些已经正确接收的分组。<br>所需序号的范围和对缓冲的要求取决于数据传输协议如何处理丢失、损坏及延时过大的分组。<br>流水线的差错恢复有两种基本方法：<br>回退 N 步<br>选择重传<br>这里写图片描述<br>3.4.3 回退 N 步（GBN，又叫滑动窗口协议）<br>在 回退 N 步协议 中，允许发送方发送多个分组而不需等待确认，但它也受限于在流水线中未确认的分组数不能超过某个最大允许数 N。<br>这里写图片描述<br>基序号（base）为最早的未确认分组的序号。<br>下一个序号（nextseqnum）为下一个待发分组的的序号。<br>N 常被称为 窗口长度，GBN 协议也常被称为 滑动窗口协议。<br>GBN 的发送方必须响应三种类型的事件：<br>上层的调用：若窗口未满，则产生一个分组将其发送。<br>收到一个 ACK：对序号为 n 的分组的确认采取 累积确认，表明接收方已正确接收到包括 n 的序号在内的 n 的以前的所有分组。<br>超时事件：只使用一个定时器，即最早的已发送但未被确认的分组所使用的定时器。如果出现超时，则发送方重传所有已发送但还未被确认的分组。如果收到一个 ACK，但仍有已发送但未被确认的分组，则重启定时器。如果没有已发送但未确认的分组，该定时器被终止。<br>GBN正常传输时<br>这里写图片描述<br>GBN丢失帧时<br>这里写图片描述<br>3.4.4 选择重传（SR）<br>GBN 也存在一些性能问题，单个分组的错误会引起大量分组的重传。<br>选择重传 通过让发送方仅重传那些它怀疑在接收方出错的分组而避免了不必要的重传。<br>下图是选择重传发送方和接收方的序号空间：<br>这里写图片描述<br>SR 发送方的事件和动作：<br>从上层接收数据： 检查下一个可用于该分组的序号，若在发送方的窗口内，则将数据打包发送。<br>超时： 定时器再次用来防止丢失分组。但是现在每个分组必须得有单独的定时器。<br>收到 ACK：倘若该分组序号在窗口内，则 SR 发送方将那个被确认的分组标记为已接收。如果该分组的序号等于send_base，则窗口基序号向前移动到具有最小序号的未确认分组处。如果窗口移动了并且该序号落在窗口内的未发送分组，则发送这些分组。<br>SR 接收方将确认一个正确接收的分组而不管其是否按序。<br>SR 接收方的事件和动作：<br>序号在 [rcv_base, rcv_base + N -1] 内的分组被正确接收：在此情况下，收到的分组落在接收方的窗口内，一个选择 ACK 被回送给发送方。如果该分组以前没收到过，则缓存该分组。如果该分组的序号等于接收窗口的基序号，则该分组及以前缓存的序号连续的分组交付给上层。<br>序号在 [rcv_base - N, rcv_base - 1] 内的分组被正确接收： 产生一个 ACK，即使该分组是接收方以前已确认过的分组。<br>其他情况：忽略该分组。<br>窗口长度必须小于或等于序号空间大小的一半。<br>这里写图片描述<br>问题<br>这里写图片描述<br>接收方：在(a)和(b)两种情况下接收方没有发现差别!<br>在 (a)中不正确地将新的冗余的当为新的，而在(b)中不正确地将新的当作冗余的<br>3.5 面向连接的运输：TCP<br>3.5.1 TCP 连接<br>特点<br>TCP是面向连接的<br>通信前需要建立连接，通信结束需要释放连接。<br>TCP提供可靠交付服务<br>所谓『可靠』指的是：TCP发送的数据无重复、无丢失、无错误、与发送端顺序一致。<br>TCP是面向字节流的<br>所谓『面向字节流』指的是：TCP以字节为单位。虽然传输的过程中数据被划分成一个个数据报，但这只是为了方便传输，接收端最终接受到的数据将与发送端的数据一模一样。<br>TCP提供全双工通信<br>所谓『全双工通信』指的是：TCP的两端既可以作为发送端，也可以作为接收端。<br>一条TCP连接的两端只能有两个端点<br>TCP只能提供点到点的通信，而UDP可以任意方式的通信。<br>TCP连接与套接字<br>什么是『TCP连接』？<br>TCP连接是一种抽象的概念，表示一条可以通信的链路。<br>每条TCP连接有且仅有两个端点，表示通信的双方。且双发在任意时刻都可以作为发送者和接收者。<br>什么是『套接字』？<br>一条TCP连接的两端就是两个套接字。<br>套接字=IP地址:端口号。<br>因此，TCP连接=（套接字1，套接字2）=（IP1:端口号1，IP2:端口号2）<br>TCP三次握手<br>这里写图片描述<br>PS：TCP协议中，主动发起请求的一端称为『客户端』，被动连接的一端称为『服务端』。不管是客户端还是服务端，TCP连接建立完后都能发送和接收数据。</p>
<p>起初，服务器和客户端都为CLOSED状态。在通信开始前，双方都得创建各自的传输控制块（TCB）。<br>服务器创建完TCB后遍进入LISTEN状态，此时准备接收客户端发来的连接请求。</p>
<p>第一次握手<br>客户端向服务端发送连接请求报文段。该报文段的头部中SYN=1，ACK=0，seq=x。请求发送后，客户端便进入SYN-SENT状态。</p>
<p>PS1：SYN=1，ACK=0表示该报文段为连接请求报文。<br>PS2：x为本次TCP通信的字节流的初始序号。<br>TCP规定：SYN=1的报文段不能有数据部分，但要消耗掉一个序号。<br>第二次握手<br>服务端收到连接请求报文段后，如果同意连接，则会发送一个应答：SYN=1，ACK=1，seq=y，ack=x+1。<br>该应答发送完成后便进入SYN-RCVD状态。</p>
<p>PS1：SYN=1，ACK=1表示该报文段为连接同意的应答报文。<br>PS2：seq=y表示服务端作为发送者时，发送字节流的初始序号。<br>PS3：ack=x+1表示服务端希望下一个数据报发送序号从x+1开始的字节。<br>第三次握手<br>当客户端收到连接同意的应答后，还要向服务端发送一个确认报文段，表示：服务端发来的连接同意应答已经成功收到。<br>该报文段的头部为：ACK=1，seq=x+1，ack=y+1。<br>客户端发完这个报文段后便进入ESTABLISHED状态，服务端收到这个应答后也进入ESTABLISHED状态，此时连接的建立完成！</p>
<p>为什么连接建立需要三次握手，而不是两次握手？<br>防止失效的连接请求报文段被服务端接收，从而产生错误。</p>
<p>PS：失效的连接请求：若客户端向服务端发送的连接请求丢失，客户端等待应答超时后就会再次发送连接请求，此时，上一个连接请求就是『失效的』。</p>
<p>若建立连接只需两次握手，客户端并没有太大的变化，仍然需要获得服务端的应答后才进入ESTABLISHED状态，而服务端在收到连接请求后就进入ESTABLISHED状态。此时如果网络拥塞，客户端发送的连接请求迟迟到不了服务端，客户端便超时重发请求，如果服务端正确接收并确认应答，双方便开始通信，通信结束后释放连接。此时，如果那个失效的连接请求抵达了服务端，由于只有两次握手，服务端收到请求就会进入ESTABLISHED状态，等待发送数据或主动发送数据。但此时的客户端早已进入CLOSED状态，服务端将会一直等待下去，这样浪费服务端连接资源。</p>
<p>三次握手后<br>发送方通过套接字向TCP的发送缓存中传输数据，当数据达到最大报文段长（MSS）时TCP就将缓存加上一个TCP首部形成报文段发送给接收方的TCP接收缓存。</p>
<p>TCP四次挥手<br>这里写图片描述<br>TCP连接的释放一共需要四步，因此称为『四次挥手』。<br>我们知道，TCP连接是双向的，因此在四次挥手中，前两次挥手用于断开一个方向的连接，后两次挥手用于断开另一方向的连接。</p>
<p>第一次挥手<br>若A认为数据发送完成，则它需要向B发送连接释放请求。该请求只有报文头，头中携带的主要参数为：<br>FIN=1，seq=u。此时，A将进入FIN-WAIT-1状态。</p>
<p>PS1：FIN=1表示该报文段是一个连接释放请求。<br>PS2：seq=u，u-1是A向B发送的最后一个字节的序号。<br>第二次挥手<br>B收到连接释放请求后，会通知相应的应用程序，告诉它A向B这个方向的连接已经释放。此时B进入CLOSE-WAIT状态，并向A发送连接释放的应答，其报文头包含：<br>ACK=1，seq=v，ack=u+1。</p>
<p>PS1：ACK=1：除TCP连接请求报文段以外，TCP通信过程中所有数据报的ACK都为1，表示应答。<br>PS2：seq=v，v-1是B向A发送的最后一个字节的序号。<br>PS3：ack=u+1表示希望收到从第u+1个字节开始的报文段，并且已经成功接收了前u个字节。<br>A收到该应答，进入FIN-WAIT-2状态，等待B发送连接释放请求。<br>第二次挥手完成后，A到B方向的连接已经释放，B不会再接收数据，A也不会再发送数据。但B到A方向的连接仍然存在，B可以继续向A发送数据。</p>
<p>第三次挥手<br>当B向A发完所有数据后，向A发送连接释放请求，请求头：FIN=1，ACK=1，seq=w，ack=u+1。B便进入LAST-ACK状态。</p>
<p>第四次挥手<br>A收到释放请求后，向B发送确认应答，此时A进入TIME-WAIT状态。该状态会持续2MSL时间，若该时间段内没有B的重发请求的话，就进入CLOSED状态，撤销TCB。当B收到确认应答后，也便进入CLOSED状态，撤销TCB。</p>
<p>为什么A要先进入TIME-WAIT状态，等待2MSL时间后才进入CLOSED状态？<br>为了保证B能收到A的确认应答。<br>若A发完确认应答后直接进入CLOSED状态，那么如果该应答丢失，B等待超时后就会重新发送连接释放请求，但此时A已经关闭了，不会作出任何响应，因此B永远无法正常关闭。</p>
<p>TCP连接概括<br>客户机端TCP发送一个特殊报文段，不包含应用层数据，但首部的SYN置1，并选择一个起始序号client_isn放置到该报文序号字段中。服务器接收后为该TCP建立分配TCP缓存和变量，并发送允许报文段，SYN置1，确认号为client_isn+1，序号段中则是自己的初始序号server_isn，客户端收到这个报文后也会分配缓存和变量。并发送第三个报文，SYN置0，确认字段为server_isn+1，目的是确认信息。这个过程被称作三次握手。连接终止时客户端发出FIN置1的报文，服务器也发挥FIN置1报文，客户端确认后双方释放资源。</p>
<p>3.5.2 TCP 报文段结构<br>这里写图片描述</p>
<p>16 比特的 源端口号 和 16 比特的目的 端口号。用于多路分解和多路复用。<br>32 比特的 序号（sequence number）字段。一个报文段的序号 是该报文段数据字段首字节的序号。<br>32 比特的 确认号（Acknowledgement number）字段。主机 A　填充进报文段的确认号是主机 A 期望从主机 B 收到的下一字节的序号<br>16 比特的 接收窗口（Receive window）字段。用于指示接收方愿意接收的字节数量。<br>4 比特的 首部长度（header length）字段。指示了以 32 比特的字为单位的 TCP 首部长度。<br>可变与变长的 选项（options）字段。用于发送方与接收方协商最大报文段长度时，或在高速网络环境下作用窗口调节因子时使用。<br>6 比特的 标志（flag）字段。<br>ACK 是对成功接收一个报文段的确认。<br>RST、SYN 和 FIN 用于连接的建立和拆除。<br>PSH 被设置时，指示接收方应立即将数据交给上层。<br>URG 比特用来指示报文段里存在着被发送端上层实体置为“紧急”的数据。紧急的最后一个字节由 16 比特的 紧急数据指针（Urgent data pointer）字段 指出。<br>注：在实践中，PSH 、URG 和 紧急数据指针 并不 使用。<br>3.5.3 往返时间的估计与超时<br>如何设置TCP 超时值<br>应大于RTT：但RTT是变化的<br>太短: 过早超时，不必要的重传<br>太长: 对报文段的丢失响应太慢<br>TCP采用超时/重传机制处理报文段丢失<br>估计往返时间<br>报文段的样本RTT：SampleRTT<br>SampleRTT 均值：EstimatedRTT<br>EstimatedRTT=0.875∗EstimeatedRTT+0.125∗SampleRTT<br>设置和管理超时重传时间<br>TimeoutInterval=EstimatedRTT+4∗DevRTT<br>超时间隔 = 估计RTT + 4*偏差RTT<br>3.5.4 可靠数据传输<br>PS：网络层传输的数据单元为『数据报』，传输层的数据单元为『报文段』，为了方便起见可以统称为『分组』。</p>
<p>三种情况<br>A向B发送一个报文段，序号92，包含8字节，交给IP后开始等待一个来自B的确认号为100的报文段。然而确认报文段丢失，超时，A又重发相同报文段。B收到后对比序号发现已经收到过该报文段的一些字节，于是B的TCP确认后，将报文段重复的字节丢弃<br>这里写图片描述<br>A连续发了两个报文段，92，8和100，20（序号和字节）。B收到两个报文段并发送确认100和200。超时前没有一个确认到达A，超时后A重传92，8的报文，重启定时器。只要第二个报文的ACK在新的超时以前发生到达，第二个报文就不会重传。<br>这里写图片描述<br>和上面一种一样，A发送两个报文段，第一个报文段的确认在网络丢失，但是超时之前收到了第二个报文段的确认报文。因为累积确认机制，A知道B已经收到第二个以及之前的报文，不会重传了<br>这里写图片描述<br>超时间隔加倍<br>实际大多数情况下，每次TCP重传时会将下次超时间隔设为先前的两倍<br>当定时器在另外两个事件（收到上层应用数据，收到ACK）中的任意一个启动时，超时间隔又从估计RTT和偏差RTT推算得到。比如一个报文段第一次超时1s，重发，第二次超时就是2s，第三次4s…但是当收到该报文确认时，超时间隔又重置，算是一种拥塞控制<br>快速重传<br>发送方挨个发送大量报文段，如果一个丢失，很可能引起一个接一个冗余ACK（即重复的ACK，上面说过，A连续发了序号为1，2，3，4，5的报文，若B没收到2，却收到了3，4，5，则对2之后的报文都发送确认号为2的ACK）。如果TCP发送方接收到对相同数据的3个冗余ACK，它把这当做一种指示，说明这个重复确认报文段后面的报文都丢失了。一旦收到3个冗余ACK，TCP执行快速重传，即在该报文段的定时器过期之前重传丢失的报文段<br>这里写图片描述<br>回退N步 or 选择重传<br>TCP确认是累积式的，正确接收但失序的报文段是不会被接收方逐个确认的，像GBN风格<br>但是TCP和GBN有显著区别<br>许多TCP实现会将正确接收但失序的报文段缓存起来<br>GBN不仅重传未确认分组，还会重传之后所有分组，TCP只传一个或不传（若其后面的ACK超时前到来）<br>选择确认，允许接收方有选择地确认失序报文段，而不是累积确认最后一个正确接收的有序报文段。该机制与选择重传机制结合（跳过重传已确认报文段），TCP看起来像SR<br>TCP的差错恢复机制是GBN协议和SR协议的混合体<br>3.5.5 流量控制<br>什么是流量控制？<br>如果发送者发送过快，接收者来不及接收，那么就会有分组丢失。为了避免分组丢失，控制发送者的发送速度，使得接收者来得及接收，这就是流量控制。<br>流量控制是一个速度匹配服务，发送方发送速率与接收方程序读取速率相匹配<br>流量控制的目的？<br>流量控制根本目的是防止分组丢失，它是构成TCP可靠性的一方面。<br>如何实现流量控制？<br>由滑动窗口协议（连续ARQ协议，如GBN和SR）实现，TCP让发送方维护一个称为接收窗口rwnd的变量，用于给发送方指示接收方还有多少可用缓存。因为是全双工通信，双方都维护接收窗口变量。B把rwnd值放入给A的报文段接收窗口字段中，通知A自己还有多少缓存空间，A控制未确认的数据量小于rwnd，即发送方的发送窗口不可以大于接收方发回的窗口大小。<br>滑动窗口协议既保证了分组无差错、有序接收，也实现了流量控制。<br>流量控制引发的死锁<br>考虑一种特殊的情况，就是接收方若没有缓存足够使用，就会发送零窗口大小的报文，此时发送放将发送窗口设置为0，停止发送数据。之后接收方有足够的缓存，发送了非零窗口大小的报文，但是这个报文在中途丢失的，发送者一直等待下去，而接收者以为发送者已经收到该应答，等待接收新数据，这样双方就相互等待，从而产生死锁。<br>持续计时器<br>为了避免流量控制引发的死锁，TCP使用了持续计时器。每当发送者收到一个零窗口的应答后就启动该计时器。时间一到便主动发送报文询问接收者的窗口大小。若接收者仍然返回零窗口，则重置该计时器继续等待；若窗口不为0，则表示应答报文丢失了，此时重置发送窗口后开始发送，这样就避免了死锁的产生。<br>一条TCP连接每一侧主机都设置了缓存，当TCP连接收到正确有序的字节后，将数据放入缓存，应用从缓存中读取。若应用较忙，发送方发送太快太多，可能会造成缓存溢出<br>TCP发送方因为IP网络的拥塞而降速（超时间隔加倍），属于拥塞控制，不属于流量控制，虽然都是降速<br>UDP无流量控制，缓存溢出就溢出了<br>3.6 拥塞控制<br>3.6.1 拥塞原因与代价<br>丢包一般是当前网络拥塞时由于路由器缓存溢出引起，因此分组重传能作为网络拥塞的征兆，但分组重传无法解决网络拥塞<br>拥塞原因与代价<br>情况一：两个发送方和一台无穷大缓存的路由器<br>容量为R的共享式输出链路上传输<br>当发送速率超过R/2时，路由器的排队分组就会无限增加，源和目的平均时延变成无穷大<br>情况二：两个发送方和一台有限缓存的路由器<br>分组到达一个已满的缓存时会被丢弃，发送方必须执行重传以补偿因为缓存溢出丢弃的分组<br>发送方遇到高时延时，进行的不必要重传引起路由器转发不必要的分组副本<br>情况三：4个发送方和具有优先缓存的多台路由器及多条路径<br>当一个分组沿一条路径被丢弃时，每个上游路由器用于转发该分组到丢弃该分组使用的传输容量被浪费<br>拥塞控制 和 流量控制 的区别？<br>拥塞控制：拥塞控制是作用于网络的，它是防止过多的数据注入到网络中，避免出现网络负载过大的情况；<br>流量控制：流量控制是作用于接收者的，它是控制发送者的发送速度从而使接收者来得及接收。<br>拥塞控制的目的？<br>缓解网络压力<br>保证分组按时到达<br>3.6.2 拥塞控制方法<br>拥塞控制可以分为端到端的和网络辅助两种，对应网络层是否为运输层拥塞机制提供显式帮助。TCP是端到端的拥塞机制，因为其网络下层IP协议并不提供拥塞机制。按照前面说的，首先TCP可以通过控制拥塞窗口的值控制发送方流量，通过超时和连收3个冗余ACK判断网络拥塞，如果出现就缩小窗口，否则就趁机放大窗口利用空闲带宽。<br>3.7 TCP拥塞控制<br>TCP必须用端到端拥塞控制，因为IP层不向端系统提供显式网络拥塞反馈<br>TCP让每一个发送方根据感知到的拥塞程度限制其发送速率<br>如何限制其发送速率？<br>维护拥塞窗口cwnd值（注意流量控制使用接收窗口rwnd值）<br>发送方未确认数据量 &lt;= min { cwnd , rwnd }<br>如何感知它到目的地路径存在拥塞？<br>丢包：超时或收到3个冗余ACK<br>TCP是自计时的，使用确认来触发增大它的拥塞窗口长度（及其传输速率）<br>TCP发送方如何确定发送速率？<br>一个丢失的报文意味着拥塞，当丢失报文段时应当降低速率（当前速度不能正常交付，得慢点）<br>先前未确认报文段的确认到达时，增加发送方速率（当前速度能够正常交付，说明可以再快点）<br>带宽探测（试探）：TCP发送方增加速率，丢包，从该速率后退，再往前探测….（因为拥塞情况是波动的，得尽力保持在最高速率）<br>TCP拥塞控制算法<br>慢启动算法 和 拥塞避免算法<br>发送方维护一个发送窗口，发送窗口的大小取决于网络的拥塞情况和接收窗口的大小，发送窗口是动态变化的。<br>发送方还维护一个慢启动门限<br>发送窗口 &lt; 慢启动门限：使用慢启动算法<br>发送窗口 &gt; 慢启动门限：使用拥塞避免算法<br>发送窗口 = 慢启动门限：使用慢启动算法或拥塞避免算法<br>算法的具体过程：<br>慢启动<br>一开始cwnd只设为一个MSS的较小值（这就是『慢』，不过瞬间指数级加速）<br>收到一个确认，cwnd增加一个MSS ——&gt; 每过一个RTT，cwnd翻番，发送速率翻倍（1，2，4…每次发的也多一个）<br>丢包（拥塞）结束慢启动<br>将ssthresh（慢启动阈值）设置为cwnd/2，cwnd置为1重新开始慢启动<br>当cwnd=ssthresh时，结束慢启动，TCP转移到拥塞避免模式<br>收到3个冗余ACK，执行快速重传，进入快速恢复模式<br>拥塞避免<br>进入拥塞避免状态，cwnd值是上次遇到拥塞时的一半<br>每个RTT只将cwnd值增加一个MSS/cwnd字节<br>丢包，结束拥塞避免<br>超时：ssthresh更新为cwnd的一半，cwnd置为1个MSS，返回慢启动状态<br>冗余ACK：ssthresh更新为cwnd的一半，cwnd值减半，进入快速恢复状态<br>快速恢复<br>快速恢复中，每个冗余ACK，cwnd 增加一个MSS，当丢失报文的ACK到达时，TCP降低cwnd，进入拥塞避免状态<br>超时：同慢启动和拥塞避免<br>总体上来说，如果没有拥塞，TCP每收到一个正常的确认报文，就将窗口扩大一个MSS（最大报文段），也就是多发一个报文，如果出现拥塞就将窗口大小缩小一半。该算法称作加性增，乘性减。<br>首先，因为在开始阶段窗口初值一般仅为一个MSS，这样在很长一段时间内速率会很低，而可用带宽可能很大，为了尽快探明最大可用带宽，启动阶段每经过一个RTT，窗口值就增大一倍，直到出现一个报文丢失，这个特殊过程才结束。该过程称作慢启动。其次，遇到一个超时事件的时候，TCP将窗口值设成1个MSS，并慢启动到丢失报文前窗口值的一半。但是收到3个冗余ACK的时候并不慢启动而是直接减半，这种行为叫快速恢复。</p>

        
    

    
</div>


                

                <!-- Post Comments -->
                
                    
    <!-- 使用 DISQUS -->
<div id="disqus-comment">
    <div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_config = function () {
        this.page.url = 'http://blog.venus10.com/2018/06/13/《计算机网络-自顶向下方法》/';  // Replace PAGE_URL with your page's canonical URL variable
        this.page.identifier = 'http://blog.venus10.com/2018/06/13/《计算机网络-自顶向下方法》/'; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };
</script>
<script type="text/ls-javascript" id="disqus-thread-script">
    queue.offer(function() {
            (function() { // DON'T EDIT BELOW THIS LINE
                var d = document;
                var s = d.createElement('script');
                s.src = '//mars687.disqus.com/embed.js';
                s.setAttribute('data-timestamp', + new Date());
                (d.head || d.body).appendChild(s);
            })();
        });
</script>

</div>
<style>
    #disqus-comment{
        background-color: #eee;
        padding: 2pc;
    }
</style>

                
            </div>

            <!-- Post Prev & Next Nav -->
            <nav class="material-nav mdl-color-text--grey-50 mdl-cell mdl-cell--12-col">
    <!-- Prev Nav -->
    
        <a href="/2018/06/17/《计算机网络-自顶向下方法》笔记/" id="post_nav-newer" class="prev-content">
            <button class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon mdl-color--white mdl-color-text--grey-900" role="presentation">
                <i class="material-icons">arrow_back</i>
            </button>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            新篇
        </a>
    

    <!-- Section Spacer -->
    <div class="section-spacer"></div>

    <!-- Next Nav -->
    
        <a href="/2018/06/11/Day12-Day15-复杂页面的实现/" id="post_nav-older" class="next-content">
            旧篇
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            <button class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon mdl-color--white mdl-color-text--grey-900" role="presentation">
                <i class="material-icons">arrow_forward</i>
            </button>
        </a>
    
</nav>

        </div>
    </div>



                    
                        <!-- Overlay For Active Sidebar -->
<div class="sidebar-overlay"></div>

<!-- Material sidebar -->
<aside id="sidebar" class="sidebar sidebar-colored sidebar-fixed-left" role="navigation">
    <div id="sidebar-main">
        <!-- Sidebar Header -->
        <div class="sidebar-header header-cover" style="background-image: url(/img/sidebar_header.png);">
    <!-- Top bar -->
    <div class="top-bar"></div>

    <!-- Sidebar toggle button -->
    <button type="button" class="sidebar-toggle mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon" style="display: initial;" data-upgraded=",MaterialButton,MaterialRipple">
        <i class="material-icons">clear_all</i>
        <span class="mdl-button__ripple-container">
            <span class="mdl-ripple">
            </span>
        </span>
    </button>

    <!-- Sidebar Avatar -->
    <div class="sidebar-image">
        <img src="/img/avatar.png" alt="Mars687's avatar">
    </div>

    <!-- Sidebar Email -->
    <a data-toggle="dropdown" class="sidebar-brand" href="#settings-dropdown">
        tbdyfe@gmail.com
        <b class="caret"></b>
    </a>
</div>


        <!-- Sidebar Navigation  -->
        <ul class="nav sidebar-nav">
    <!-- User dropdown  -->
    <li class="dropdown">
        <ul id="settings-dropdown" class="dropdown-menu">
            
                <li>
                    <a href="#" target="_blank" title="Email Me">
                        
                            <i class="material-icons sidebar-material-icons sidebar-indent-left1pc-element">email</i>
                        
                        Email Me
                    </a>
                </li>
            
        </ul>
    </li>

    <!-- Homepage -->
    
        <li id="sidebar-first-li">
            <a href="/">
                
                    <i class="material-icons sidebar-material-icons">home</i>
                
                主页
            </a>
        </li>
        
    

    <!-- Archives  -->
    
        <li class="dropdown">
            <a href="#" class="ripple-effect dropdown-toggle" data-toggle="dropdown">
                
                    <i class="material-icons sidebar-material-icons">inbox</i>
                
                    归档
                <b class="caret"></b>
            </a>
            <ul class="dropdown-menu">
            <li>
                <a class="sidebar_archives-link" href="/archives/2018/06/">六月 2018<span class="sidebar_archives-count">3</span></a></li><li><a class="sidebar_archives-link" href="/archives/2018/05/">五月 2018<span class="sidebar_archives-count">12</span></a></li><li><a class="sidebar_archives-link" href="/archives/2018/04/">四月 2018<span class="sidebar_archives-count">11</span></a>
            </ul>
        </li>
        
    

    <!-- Categories  -->
    
        <li class="dropdown">
            <a href="#" class="ripple-effect dropdown-toggle" data-toggle="dropdown">
                
                    <i class="material-icons sidebar-material-icons">chrome_reader_mode</i>
                
                分类
                <b class="caret"></b>
            </a>
            <ul class="dropdown-menu">
                <li>
                <a class="sidebar_archives-link" href="/categories/CSS/">CSS<span class="sidebar_archives-count">11</span></a></li><li><a class="sidebar_archives-link" href="/categories/HTTP/">HTTP<span class="sidebar_archives-count">1</span></a></li><li><a class="sidebar_archives-link" href="/categories/IFE/">IFE<span class="sidebar_archives-count">6</span></a></li><li><a class="sidebar_archives-link" href="/categories/JavaScript/">JavaScript<span class="sidebar_archives-count">1</span></a></li><li><a class="sidebar_archives-link" href="/categories/JavaScript-DOM/">JavaScript-DOM<span class="sidebar_archives-count">1</span></a></li><li><a class="sidebar_archives-link" href="/categories/Network/">Network<span class="sidebar_archives-count">2</span></a></li><li><a class="sidebar_archives-link" href="/categories/ajax/">ajax<span class="sidebar_archives-count">1</span></a></li><li><a class="sidebar_archives-link" href="/categories/life/">life<span class="sidebar_archives-count">1</span></a></li><li><a class="sidebar_archives-link" href="/categories/webpack/">webpack<span class="sidebar_archives-count">1</span></a>
            </ul>
        </li>
        
    

    <!-- Pages  -->
    

    <!-- Article Number  -->
    
        <li>
            <a href="/archives">
                文章总数
                <span class="sidebar-badge">26</span>
            </a>
        </li>
        
    
</ul>


        <!-- Sidebar Footer -->
        <!--
I'm glad you use this theme, the development is no so easy, I hope you can keep the copyright, I will thank you so much.
If you still want to delete the copyrights, could you still retain the first one? Which namely "Theme Material"
It will not impact the appearance and can give developers a lot of support :)

很高兴您使用并喜欢该主题，开发不易 十分谢谢与希望您可以保留一下版权声明。
如果您仍然想删除的话 能否只保留第一项呢？即 "Theme Material"
它不会影响美观并可以给开发者很大的支持和动力。 :)
-->

<!-- Sidebar Divider -->

    <div class="sidebar-divider"></div>


<!-- Theme Material -->

    <a href="https://github.com/viosey/hexo-theme-material"  class="sidebar-footer-text-a" target="_blank">
        <div class="sidebar-text mdl-button mdl-js-button mdl-js-ripple-effect sidebar-footer-text-div" data-upgraded=",MaterialButton,MaterialRipple">
            主题 - Material
            <span class="sidebar-badge badge-circle">i</span>
        </div>
    </a>


<!-- Help & Support -->
<!--

-->

<!-- Feedback -->
<!--

-->

<!-- About Theme -->
<!--

-->

    </div>

    <!-- Sidebar Image -->
    

</aside>

                    

                    
                        <!-- Footer Top Button -->
                        <div id="back-to-top" class="toTop-wrap">
    <a href="#top" class="toTop">
        <i class="material-icons footer_top-i">expand_less</i>
    </a>
</div>

                    

                    <!--Footer-->
<footer class="mdl-mini-footer" id="bottom">
    
        <!-- Paradox Footer Left Section -->
        <div class="mdl-mini-footer--left-section sns-list">
    <!-- Twitter -->
    
        <a href="https://twitter.com/twitter" target="_blank">
            <button class="mdl-mini-footer--social-btn social-btn footer-sns-twitter">
                <span class="visuallyhidden">Twitter</span>
            </button><!--
     --></a>
    

    <!-- Facebook -->
    
        <a href="https://www.facebook.com/facebook" target="_blank">
            <button class="mdl-mini-footer--social-btn social-btn footer-sns-facebook">
                <span class="visuallyhidden">Facebook</span>
            </button><!--
     --></a>
    

    <!-- Google + -->
    
        <a href="https://www.google.com/" target="_blank">
            <button class="mdl-mini-footer--social-btn social-btn footer-sns-gplus">
                <span class="visuallyhidden">Google Plus</span>
            </button><!--
     --></a>
    

    <!-- Weibo -->
    

    <!-- Instagram -->
    

    <!-- Tumblr -->
    

    <!-- Github -->
    

    <!-- LinkedIn -->
    

    <!-- Zhihu -->
    

    <!-- Bilibili -->
    

    <!-- Telegram -->
    
    
    <!-- V2EX -->
    
</div>


        <!--Copyright-->
        <div id="copyright">
            Copyright&nbsp;©<script type="text/javascript">var fd = new Date();document.write("&nbsp;" + fd.getFullYear() + "&nbsp;");</script>星辰大海
            
        </div>

        <!-- Paradox Footer Right Section -->

        <!--
        I am glad you use this theme, the development is no so easy, I hope you can keep the copyright.
        It will not impact the appearance and can give developers a lot of support :)

        很高兴您使用该主题，开发不易，希望您可以保留一下版权声明。
        它不会影响美观并可以给开发者很大的支持。 :)
        -->

        <div class="mdl-mini-footer--right-section">
            <div>
                <div class="footer-develop-div">Powered by <a href="https://hexo.io" target="_blank" class="footer-develop-a">Hexo</a></div>
                <div class="footer-develop-div">Theme - <a href="https://github.com/viosey/hexo-theme-material" target="_blank" class="footer-develop-a">Material</a></div>
            </div>
        </div>
    
</footer>


                    <!-- Import JS File -->

    <script>lsloader.load("lazyload_js","/js/lazyload.min.js?wgjW/HuQG9JDgvPDPoRAng==", true)</script>



    <script>lsloader.load("js_js","/js/js.min.js?V/53wGualMuiPM3xoetD5Q==", true)</script>



    <script>lsloader.load("np_js","/js/nprogress.js?pl3Qhb9lvqR1FlyLUna1Yw==", true)</script>


<script type="text/ls-javascript" id="NProgress-script">
    NProgress.configure({
        showSpinner: true
    });
    NProgress.start();
    $('#nprogress .bar').css({
        'background': '#29d'
    });
    $('#nprogress .peg').css({
        'box-shadow': '0 0 10px #29d, 0 0 15px #29d'
    });
    $('#nprogress .spinner-icon').css({
        'border-top-color': '#29d',
        'border-left-color': '#29d'
    });
    setTimeout(function() {
        NProgress.done();
        $('.fade').removeClass('out');
    }, 800);
</script>



    
        <script>lsloader.load("sm_js","/js/smoothscroll.js?tNQK2Tw2SUL8a1Scn/Mgew==", true)</script>
    







   <!-- 使用 DISQUS js 代码 -->
<script id="dsq-count-scr" src="//mars687.disqus.com/count.js" async></script>





<!-- UC Browser Compatible -->
<script>
	var agent = navigator.userAgent.toLowerCase();
	if(agent.indexOf('ucbrowser')>0) {
		document.write('<link rel="stylesheet" href="/css/uc.css">');
	   alert('由于 UC 浏览器使用极旧的内核，而本网站使用了一些新的特性。\n为了您能更好的浏览，推荐使用 Chrome 或 Firefox 浏览器。');
	}
</script>

<!-- Import prettify js  -->


    
        <script>lsloader.load("hanabi","/js/hanabi-browser-bundle.js?5+2z7ZZmFuZK5IcimlZbxw==", true)</script>
    


<!-- Window Load -->
<!-- add class for prettify -->
<script type="text/ls-javascript" id="window-load">
    $(window).on('load', function() {
        // Post_Toc parent position fixed
        $('.post-toc-wrap').parent('.mdl-menu__container').css('position', 'fixed');
    });

    
    
        
        
        HanabiBrowser.start('pre code',true);
    
</script>

<!-- MathJax Load-->


<!-- Bing Background -->


<script type="text/ls-javascript" id="lazy-load">
    // Offer LazyLoad
    queue.offer(function(){
        $('.lazy').lazyload({
            effect : 'show'
        });
    });

    // Start Queue
    $(document).ready(function(){
        setInterval(function(){
            queue.execNext();
        },200);
    });
</script>

<!-- Custom Footer -->



<script>
    (function(){
        var scriptList = document.querySelectorAll('script[type="text/ls-javascript"]')

        for (var i = 0; i < scriptList.length; ++i) {
            var item = scriptList[i];
            lsloader.runInlineScript(item.id,item.id);
        }
    })()
console.log('\n %c © Material Theme | Version: 1.5.2 | https://github.com/viosey/hexo-theme-material %c \n', 'color:#455a64;background:#e0e0e0;padding:5px 0;border-top-left-radius:5px;border-bottom-left-radius:5px;', 'color:#455a64;background:#e0e0e0;padding:5px 0;border-top-right-radius:5px;border-bottom-right-radius:5px;');
</script>

                </main>
            </div>
        </body>
    
</html>
